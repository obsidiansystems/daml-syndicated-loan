module Scripts.Settlement where

import Daml.Script

-- INTERFACE DEPENDENCIES --
import Daml.Finance.Interface.Holding.Base qualified as Holding (I)
import Daml.Finance.Interface.Types.Common.Types (AccountKey, Id(..), InstrumentKey(..))

-- IMPLEMENTATION DEPENDENCIES --
import Daml.Finance.Instrument.Bond.FixedRate.Instrument qualified as FR
--import Daml.Finance.Interface.Instrument.Bond.FixedRate.Instrument qualified as FR

import Scripts.Transfer (TransferState(..), runTransfer)

import DA.Date (Month(..), date, toGregorian)
import Daml.Finance.Interface.Types.Date.Calendar qualified as Cal
import Daml.Finance.Interface.Types.Date.DayCount (DayCountConventionEnum(..))
import Daml.Finance.Interface.Types.Date.RollConvention (Period(..), PeriodEnum(..), RollConventionEnum(..))
import Daml.Finance.Interface.Types.Date.Schedule qualified as Sched
import Daml.Finance.Interface.Types.Date.Schedule (PeriodicSchedule(..))
import Daml.Finance.Data.Time.DateClock.Types qualified as DateClock
import Daml.Finance.Interface.Types.Date.Classes

import Workflow.Servicing (clockUpdateEvent)
import qualified DA.Set as Set
import Daml.Finance.Lifecycle.Rule.Claim as Claim
import Daml.Finance.Interface.Lifecycle.Rule.Claim as ClaimI
--import Daml.Finance.Claims.Lifecycle.Rule as Lifecycle (Rule(..))
import qualified Daml.Finance.Interface.Lifecycle.Rule.Lifecycle as Lifecycle
import qualified DA.Map as Map
import qualified Daml.Finance.Interface.Instrument.Base.Instrument as BaseInstrument
import DA.Time (days, time)
import Workflow.Util
import qualified Daml.Finance.Claims.Lifecycle.Rule as Lifecycle

import Tests.Common
import Tests.IDE

-- | Helper container used to transfer state from one script to another.
data SettlementState = SettlementState
  with
    alice : Party
    bank : Party
    bob : Party
    public : Party
    aliceAccount : AccountKey
    bobAccount : AccountKey
    usdInstrument : InstrumentKey
    bondInstrument : InstrumentKey
    bobHoldingCid : ContractId Holding.I
  deriving (Eq, Show)

-- | Create a schedule for periodic payments.
createPaymentPeriodicSchedule : Date -> [Text] -> Cal.BusinessDayConventionEnum -> PeriodEnum ->
  Int -> Date -> Date -> PeriodicSchedule
createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod
  couponPeriodMultiplier issueDate maturityDate = do
    -- CREATE_PERIODIC_SCHEDULE_BEGIN
    let
      (y, m, d) = toGregorian firstCouponDate
      periodicSchedule = PeriodicSchedule with
        businessDayAdjustment =
          Cal.BusinessDayAdjustment with
            calendarIds = holidayCalendarIds
            convention = businessDayConvention
        effectiveDateBusinessDayAdjustment = None
        terminationDateBusinessDayAdjustment = None
        frequency =
          Sched.Periodic Sched.Frequency with
            rollConvention = DOM d
            period = Period with
              period = couponPeriod
              periodMultiplier = couponPeriodMultiplier
        effectiveDate = issueDate
        firstRegularPeriodStartDate = Some firstCouponDate
        lastRegularPeriodEndDate = Some maturityDate
        stubPeriodType = None
        terminationDate = maturityDate
    -- CREATE_PERIODIC_SCHEDULE_END
    periodicSchedule

run : Script ()
run = do
  p <- createParties
  po <- preOrigination p
  runBondStep p po
  return ()

-- | Test script that
-- 1. executes the `runTransfer` script
-- 2. creates a token instrument
-- 3. credits a token holding to Alice in her bank account
-- 4. atomically exchanges the token against the cash holding

runBondStep : LedgerParties -> PreOriginationStuff -> Script ()
runBondStep LedgerParties{..} PreOriginationStuff{..} = do
  {-
  -- Execute the `runTransfer` script. Bob now holds USD 1000 in his account.
  TransferState{alice
    , bank
    , bob
    , public
    , aliceAccount
    , bobAccount
    , cashInstrument = usdInstrument
    , holdingFactoryCid
    , newHoldingCid = bobHoldingCid} <- runTransfer
  -}

  orig <- origination (LedgerParties{..}) (PreOriginationStuff{..})

  setTime (time (date 2023 Apr 10) 0 0 0)

  let businessDayConvention = Cal.Following
      periodicSchedule = createPaymentPeriodicSchedule
        (date 2024 Apr 10)
        []
        businessDayConvention
        M
        1
        (date 2023 Apr 10)
        (date 2028 Apr 10)

  passTime (days 400)
  
  let borrower = borrower_bob
      lender = lender_gary
      agent = agent_charlie
      today = date 2024 May 10
      parties = Set.fromList [borrower, lender, agent]
      updateEvent = clockUpdateEvent parties parties today
  updateEventCid <- fmap toInterfaceContractId $
    submitMulti [agent_charlie,borrower_bob,lender_gary] [] $ do createCmd updateEvent
  
  rule <- fmap (toInterfaceContractId @Lifecycle.Lifecycle) $
    submit agent $ createCmd $ Lifecycle.Rule with
      providers = Set.singleton agent_charlie
      observers = Map.fromList [("bob", Set.singleton borrower_bob), ("fed", Set.singleton fed_ingrid)]
      lifecycler = agent_charlie
      id = Id "LifecycleRule"
      description = "Rule to lifecycle the bond instrument"

  {-
  rule <- fmap (toInterfaceContractId @ClaimI.I) $
    submit agent $ createCmd $ Claim.Rule with
      providers = Set.fromList [agent, bob]
      claimers = Set.singleton bob
      settlers = Set.singleton bob
      routeProviderCid = undefined
      settlementFactoryCid = undefined
      netInstructions = undefined
  -}
  
  (newBondOpt, effectCids) <- submit agent_charlie $
    exerciseCmd rule Lifecycle.Evolve with
      eventCid = updateEventCid
      observableCids = []
      instrument = orig.bond.reference

  case newBondOpt of
    None -> debug "NO NEW STUFF"
    Some b -> debug $ show b

  return ()
