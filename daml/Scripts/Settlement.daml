module Scripts.Settlement where

import Daml.Script

import DA.Date (toDateUTC, Month(..), date, toGregorian)
import qualified DA.Map as Map
import qualified DA.Set as Set
import DA.Time (time)

import Daml.Finance.Claims.Lifecycle.Rule qualified as LifecycleRule (Rule(..))
import Daml.Finance.Interface.Holding.Base qualified as Holding (I)
import Daml.Finance.Interface.Lifecycle.Rule.Claim qualified as Claim (I(..), ClaimEffect(..))
import Daml.Finance.Interface.Lifecycle.Rule.Lifecycle qualified as Lifecycle (Lifecycle, Evolve(..))
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Settle(..))
import Daml.Finance.Interface.Settlement.Factory qualified as Settlement (F(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..))
import Daml.Finance.Interface.Settlement.RouteProvider qualified as RouteProvider (I(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..))
import Daml.Finance.Interface.Types.Common.Types (AccountKey, Id(..), InstrumentKey(..))
import Daml.Finance.Interface.Types.Date.Calendar qualified as Cal
import Daml.Finance.Interface.Types.Date.RollConvention (Period(..), PeriodEnum(..), RollConventionEnum(..))
import Daml.Finance.Interface.Types.Date.Schedule (PeriodicSchedule(..))
import Daml.Finance.Interface.Types.Date.Schedule qualified as Sched
import Daml.Finance.Lifecycle.Rule.Claim as Claim (Rule(..))
import Daml.Finance.Settlement.Batch qualified as B
import Daml.Finance.Settlement.Factory (observers, provider, Factory(Factory))
import Daml.Finance.Settlement.Hierarchy (Hierarchy(..))
import Daml.Finance.Settlement.RouteProvider.IntermediatedStatic (IntermediatedStatic(..))

import Tests.Common
import Tests.IDE
import Util.Display
import Workflow.Servicing (clockUpdateEvent)

-- | Helper container used to transfer state from one script to another.
data SettlementState = SettlementState
  with
    alice : Party
    bank : Party
    bob : Party
    public : Party
    aliceAccount : AccountKey
    bobAccount : AccountKey
    usdInstrument : InstrumentKey
    bondInstrument : InstrumentKey
    bobHoldingCid : ContractId Holding.I
  deriving (Eq, Show)

-- | Create a schedule for periodic payments.
createPaymentPeriodicSchedule : Date -> [Text] -> Cal.BusinessDayConventionEnum -> PeriodEnum ->
  Int -> Date -> Date -> PeriodicSchedule
createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod
  couponPeriodMultiplier issueDate maturityDate = do
    -- CREATE_PERIODIC_SCHEDULE_BEGIN
    let
      (y, m, d) = toGregorian firstCouponDate
      periodicSchedule = PeriodicSchedule with
        businessDayAdjustment =
          Cal.BusinessDayAdjustment with
            calendarIds = holidayCalendarIds
            convention = businessDayConvention
        effectiveDateBusinessDayAdjustment = None
        terminationDateBusinessDayAdjustment = None
        frequency =
          Sched.Periodic Sched.Frequency with
            rollConvention = DOM d
            period = Period with
              period = couponPeriod
              periodMultiplier = couponPeriodMultiplier
        effectiveDate = issueDate
        firstRegularPeriodStartDate = Some firstCouponDate
        lastRegularPeriodEndDate = Some maturityDate
        stubPeriodType = None
        terminationDate = maturityDate
    -- CREATE_PERIODIC_SCHEDULE_END
    periodicSchedule

runCreateParties : Script LedgerParties
runCreateParties = createParties

runPreOrigination : Script (LedgerParties, PreOriginationStuff)
runPreOrigination = do
  parties <- createParties
  preOrig <- preOrigination parties
  pure (parties, preOrig)

runOrigination : Script (LedgerParties, PreOriginationStuff, Origination)
runOrigination = do
  (parties, preOrig) <- runPreOrigination
  orig <- origination parties preOrig
  pure (parties, preOrig, orig)

run : Script ()
run = do
  setTime (time (date 2023 Apr 12) 4 4 4)
  p <- createParties
  po <- preOrigination p
  runBondStep p po
  return ()

-- | Test script that
-- 1. executes the `runTransfer` script
-- 2. creates a token instrument
-- 3. credits a token holding to Alice in her bank account
-- 4. atomically exchanges the token against the cash holding

runBondStep : LedgerParties -> PreOriginationStuff -> Script ()
runBondStep LedgerParties{..} PreOriginationStuff{..} = do
  let borrower = borrower_alice
      lender = lender_gary
      agent = agent_charlie
  {-
  -- Execute the `runTransfer` script. Bob now holds USD 1000 in his account.
  TransferState{alice
    , bank
    , bob
    , public
    , aliceAccount
    , bobAccount
    , cashInstrument = usdInstrument
    , holdingFactoryCid
    , newHoldingCid = bobHoldingCid} <- runTransfer
  -}
  -- 1. Create Route Provider
  routeProviderCid <- toInterfaceContractId @RouteProvider.I <$> submit borrower do
      createCmd IntermediatedStatic with
        provider = borrower
        observers = Set.fromList [borrower, lender]
        paths = Map.fromList
          [ ("LoanInstrument", Hierarchy with
              rootCustodian = borrower
              pathsToRootCustodian = [[lender_gary]]
            )
          , ("USD", Hierarchy with
              rootCustodian = fed_ingrid
              pathsToRootCustodian = [[borrower_alice], [lender_gary]]
            )
          ]

  -- 2. Create Settlement Factory
  settlementFactoryCid <- toInterfaceContractId @Settlement.F <$> submit borrower do
    createCmd Factory with
      provider = borrower
      observers = Set.fromList [borrower]


  orig <- origination (LedgerParties{..}) (PreOriginationStuff{..})
  now <- getTime

  let (y',m',d') = toGregorian (toDateUTC now)
      today = date (y'+1) m' d'
      parties = Set.fromList [borrower, lender, agent]
      updateEvent = clockUpdateEvent parties parties today
  updateEventCid <- fmap toInterfaceContractId $
    submitMulti [agent,borrower,lender] [] $ do createCmd updateEvent

  lifecycleRule <- fmap (toInterfaceContractId @Lifecycle.Lifecycle) $
    submitMulti [agent, borrower] [] $ createCmd $ LifecycleRule.Rule with
      providers = Set.fromList [borrower]
      observers = Map.empty
      lifecycler = agent
      id = Id "LifecycleRule"
      description = "Rule to lifecycle the bond instrument"

  claimRule <- fmap (toInterfaceContractId @Claim.I) $
    submit borrower_alice $ createCmd $ Claim.Rule with
      providers = Set.fromList [borrower]
      claimers = Set.singleton lender
      settlers = Set.fromList [lender, borrower, agent]
      routeProviderCid
      settlementFactoryCid
      netInstructions = False

  (newBondOpt, [effectCid]) <- submitMulti [agent, borrower] [] $
    exerciseCmd lifecycleRule Lifecycle.Evolve with
      eventCid = updateEventCid
      instrument = orig.bond.reference
      observableCids = []

  claimResult <- submitMulti [agent, borrower, lender] [] $
    exerciseCmd claimRule Claim.ClaimEffect with
      claimer = lender
      holdingCids = [orig.garyBondHoldingKey]
      effectCid
      batchId = Id "Loan interest payment"

  -- Allocate and Approve
  let [bondConsumed, bondProduced, couponProduced] = claimResult.instructionCids

  (bondConsumed2, _) <- submit lender $ exerciseCmd bondConsumed Instruction.Allocate with
    actors = Set.fromList [lender]
    allocation = Pledge orig.garyBondHoldingKey
  submit borrower $ exerciseCmd bondConsumed2 Instruction.Approve with
    actors = Set.fromList [borrower]
    approval = DebitSender

  (bondProduced2, _) <- submit borrower $ exerciseCmd bondProduced Instruction.Allocate with
    actors = Set.fromList [borrower]
    allocation = CreditReceiver
  submit lender $ exerciseCmd bondProduced2 Instruction.Approve with
    actors = Set.fromList [lender]
    approval = TakeDelivery orig.garyBondAccountKey

  (couponProduced2, _) <- submit borrower $ exerciseCmd couponProduced Instruction.Allocate with
    actors = Set.fromList [borrower]
    allocation = Pledge aliceCashHoldingCid
  submit lender $ exerciseCmd couponProduced2 Instruction.Approve with
    actors = Set.fromList [lender]
    approval = TakeDelivery ledgerAccounts.garyAccount

  batch <- queryContractId borrower_alice $ fromInterfaceContractId @B.Batch claimResult.batchCid
  logSome ("No batch found for: " <> show claimResult.batchCid) batch

  submitMulti [borrower_alice, agent_charlie] [] do
    exerciseCmd claimResult.batchCid Batch.Settle with
      actors = Set.fromList [borrower_alice, agent_charlie]

  return ()