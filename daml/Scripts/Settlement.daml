{-# LANGUAGE MultiWayIf #-}

module Scripts.Settlement where

import Daml.Script

import DA.Date
import DA.Foldable
import DA.Set qualified as Set
import DA.Map qualified as Map
import DA.Time (time)

import Daml.Finance.Interface.Holding.Base qualified as Holding (Base)
import Daml.Finance.Interface.Lifecycle.Effect (Effect)
import Daml.Finance.Interface.Lifecycle.Rule.Claim qualified as Claim (ClaimEffect(..))
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Settle(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..))
import Daml.Finance.Interface.Types.Common.Types (AccountKey, Id(..), InstrumentKey(..))
import Daml.Finance.Settlement.Batch qualified as B
import Daml.Finance.Settlement.Instruction qualified as Settlement

import Scripts.Parties
import Scripts.PreOrigination
import Tests.Util qualified as Util
import Util.Display
import Util.Script
import Workflow.Origination

-- | Helper container used to transfer state from one script to another.
data SettlementState = SettlementState
  with
    alice : Party
    bank : Party
    bob : Party
    public : Party
    aliceAccount : AccountKey
    bobAccount : AccountKey
    usdInstrument : InstrumentKey
    bondInstrument : InstrumentKey
  deriving (Eq, Show)

runAllBondSteps : LedgerParties -> PreOrigination -> Party -> Time -> ContractId OriginatedLoanAgreement -> Int -> Script ()
runAllBondSteps p po agent startTime currentOriginatedLoanAgreement yearNum = do
  let (y',m',d') = toGregorian (toDateUTC startTime)
      newDate = date (y'+yearNum) m' d'
  setTime (time newDate 4 4 4)
  result <- runBondStep p po agent currentOriginatedLoanAgreement newDate
  case result of
    Some newOriginatedLoanAgreement -> runAllBondSteps p po agent startTime newOriginatedLoanAgreement (yearNum + 1)
    None -> pure ()

-- | Test script that
-- 1. executes the `runTransfer` script
-- 2. creates a token instrument
-- 3. credits a token holding to Alice in her bank account
-- 4. atomically exchanges the token against the cash holding

runBondStep : LedgerParties -> PreOrigination -> Party -> ContractId OriginatedLoanAgreement -> Date -> Script (Optional (ContractId OriginatedLoanAgreement))
runBondStep LedgerParties{..} PreOrigination{..} agent origLoanAgreementCid today = do
  log "-- Servicing: Running Repayment Step --"
  Some origLoanAgreement <- queryContractId agent origLoanAgreementCid

  (newOrigLoanAgreement, [effectCid]) <- submit agent $ exerciseCmd origLoanAgreementCid OriginatedLoanAgreement_Lifecycle with
    today

  processLenderClaim $ LenderClaimConfig with
    agent
    origLoanAgreement
    effectCid
    bondKey = origLoanAgreement.bondKey
    borrower = borrower_alice
    lender = lender_gary
    lenderLoanAccount = ledgerAccounts.garyLoanAccount
    lenderCashAccount = ledgerAccounts.garyAccount
    borrowerCashAccount = ledgerAccounts.aliceAccount

  _resultCids <- processLenderClaim $ LenderClaimConfig with
    agent
    origLoanAgreement
    effectCid
    bondKey = origLoanAgreement.bondKey
    borrower = borrower_alice
    lender = lender_hortense
    lenderLoanAccount = ledgerAccounts.hortenseLoanAccount
    lenderCashAccount = ledgerAccounts.hortenseAccount
    borrowerCashAccount = ledgerAccounts.aliceAccount

  return newOrigLoanAgreement

data LenderClaimConfig = LenderClaimConfig with
  origLoanAgreement : OriginatedLoanAgreement
  effectCid : ContractId Effect
  bondKey : InstrumentKey
  lender : Party
  lenderLoanAccount : AccountKey
  lenderCashAccount : AccountKey
  borrower : Party
  borrowerCashAccount : AccountKey
  agent : Party

processLenderClaim : LenderClaimConfig -> Script ()
processLenderClaim LenderClaimConfig{..} = do
  Some lenderLoanHoldingCid <- Util.getHoldingOfAmount
    lenderLoanAccount
    bondKey
    None
    Set.empty
  let lenderLoanHoldingBase = toInterfaceContractId @Holding.Base lenderLoanHoldingCid

  claimResult <- submit lender $
    exerciseCmd origLoanAgreement.claimRule Claim.ClaimEffect with
      claimer = lender
      holdingCids = [lenderLoanHoldingBase]
      effectCid
      batchId = Id "Loan interest payment"

  -- Allocate and Approve
  let processInstruction instructionCid = do
        Some instruction <- queryInterfaceContractId agent instructionCid
        if
          | instruction.routedStep.sender == lender -> do
            (instructionCid2, _) <- submit lender $ exerciseCmd instructionCid Instruction.Allocate with
              actors = Set.fromList [lender]
              allocation = Pledge lenderLoanHoldingBase
            submit_ borrower $ exerciseCmd instructionCid2 Instruction.Approve with
              actors = Set.fromList [borrower]
              approval = DebitSender
          | instruction.routedStep.sender == borrower && instruction.routedStep.custodian == borrower -> do
            (instructionCid2, _) <- submit borrower $ exerciseCmd instructionCid Instruction.Allocate with
              actors = Set.fromList [borrower]
              allocation = CreditReceiver
            submit_ lender $ exerciseCmd instructionCid2 Instruction.Approve with
              actors = Set.fromList [lender]
              approval = TakeDelivery lenderLoanAccount
          | instruction.routedStep.sender == borrower && instruction.routedStep.custodian /= borrower -> do
            --Note: It would be better to allocate all holdings in one shot above
            allHoldings <- Util.getAccountHoldings borrowerCashAccount instruction.routedStep.quantity.unit
            let ignored = Set.fromList $ fst <$> filter ((/=Map.empty) . (.observers) . snd) allHoldings
            Some borrowerCashUsed <- Util.getHoldingOfAmount
              borrowerCashAccount
              instruction.routedStep.quantity.unit
              (Some instruction.routedStep.quantity.amount)
              ignored

            (instructionCid2, _) <- submit borrower $ exerciseCmd instructionCid Instruction.Allocate with
              actors = Set.fromList [borrower]
              allocation = Pledge (toInterfaceContractId @Holding.Base borrowerCashUsed)
            submit_ lender $ exerciseCmd instructionCid2 Instruction.Approve with
              actors = Set.fromList [lender]
              approval = TakeDelivery lenderCashAccount
          | otherwise -> fail "Unexpected payment instruction"
  mapA_ processInstruction claimResult.instructionCids

  logLedger
    borrower
    (fromInterfaceContractId @B.Batch claimResult.batchCid)

  submit_ agent $ do
    exerciseCmd claimResult.batchCid Batch.Settle with
      actors = Set.fromList [agent]

  return ()
