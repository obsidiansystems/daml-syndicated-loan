module Scripts.Settlement where

import Daml.Script

import DA.Date
import DA.Set qualified as Set

import Daml.Finance.Interface.Holding.Base qualified as Holding (Base)
import Daml.Finance.Interface.Lifecycle.Effect (Effect)
import Daml.Finance.Interface.Lifecycle.Rule.Claim qualified as Claim (ClaimEffect(..))
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Settle(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..))
import Daml.Finance.Interface.Types.Common.Types (AccountKey, Id(..), InstrumentKey(..))
import Daml.Finance.Settlement.Instruction qualified as Settlement
import Daml.Finance.Settlement.Batch qualified as B

import Scripts.Origination
import Scripts.Origination.Settlement
import Scripts.Parties
import Scripts.PreOrigination
import Tests.Util qualified as Util
import Util.Display
import Util.Script
import Workflow.Origination

-- | Helper container used to transfer state from one script to another.
data SettlementState = SettlementState
  with
    alice : Party
    bank : Party
    bob : Party
    public : Party
    aliceAccount : AccountKey
    bobAccount : AccountKey
    usdInstrument : InstrumentKey
    bondInstrument : InstrumentKey
  deriving (Eq, Show)

-- | Test script that
-- 1. executes the `runTransfer` script
-- 2. creates a token instrument
-- 3. credits a token holding to Alice in her bank account
-- 4. atomically exchanges the token against the cash holding

runBondStep : LedgerParties -> PreOrigination -> Origination -> Script ()
runBondStep LedgerParties{..} PreOrigination{..} orig = do
  let agent = orig.origLoanAgreement.loanAgreement.agent
      now = orig.originationTime
  let (y',m',d') = toGregorian (toDateUTC now)
      today = date (y'+1) m' d'

  lifecycleData <- submit agent $ exerciseCmd orig.origLoanAgreementCid OriginatedLoanAgreement_Lifecycle with
    today

  let [effectCid] = lifecycleData.effects

  processLenderClaim $ LenderClaimConfig with
    agent
    orig
    effectCid
    borrower = borrower_alice
    lender = lender_gary
    lenderLoanAccount = ledgerAccounts.garyLoanAccount
    lenderCashAccount = ledgerAccounts.garyAccount
    borrowerCashAccount = ledgerAccounts.aliceAccount

  _resultCids <- processLenderClaim $ LenderClaimConfig with
    agent
    orig
    effectCid
    borrower = borrower_alice
    lender = lender_hortense
    lenderLoanAccount = ledgerAccounts.hortenseLoanAccount
    lenderCashAccount = ledgerAccounts.hortenseAccount
    borrowerCashAccount = ledgerAccounts.aliceAccount

  return ()

data LenderClaimConfig = LenderClaimConfig with
  orig : Origination
  effectCid : ContractId Effect
  lender : Party
  lenderLoanAccount : AccountKey
  lenderCashAccount : AccountKey
  borrower : Party
  borrowerCashAccount : AccountKey
  agent : Party

processLenderClaim : LenderClaimConfig -> Script ()
processLenderClaim LenderClaimConfig{..} = do
  Some lenderLoanHoldingCid <- Util.getHoldingOfAmount
    lenderLoanAccount
    orig.origLoanAgreement.bondKey
    None
  let lenderLoanHoldingBase = toInterfaceContractId @Holding.Base lenderLoanHoldingCid

  claimResult <- submit lender $
    exerciseCmd orig.origLoanAgreement.claimRule Claim.ClaimEffect with
      claimer = lender
      holdingCids = [lenderLoanHoldingBase]
      effectCid
      batchId = Id "Loan interest payment"

  -- Allocate and Approve
  let [bondConsumed, bondProduced, couponProduced] = claimResult.instructionCids

  (bondConsumed2, _) <- submit lender $ exerciseCmd bondConsumed Instruction.Allocate with
    actors = Set.fromList [lender]
    allocation = Pledge lenderLoanHoldingBase
  submit_ borrower $ exerciseCmd bondConsumed2 Instruction.Approve with
    actors = Set.fromList [borrower]
    approval = DebitSender

  (bondProduced2, _) <- submit borrower $ exerciseCmd bondProduced Instruction.Allocate with
    actors = Set.fromList [borrower]
    allocation = CreditReceiver
  submit_ lender $ exerciseCmd bondProduced2 Instruction.Approve with
    actors = Set.fromList [lender]
    approval = TakeDelivery lenderLoanAccount

  Some couponProducedInstr <- queryContractId borrower (fromInterfaceContractId @Settlement.Instruction couponProduced)
  Some borrowerCashUsed <- Util.getHoldingOfAmount
    borrowerCashAccount
    couponProducedInstr.routedStep.quantity.unit
    (Some couponProducedInstr.routedStep.quantity.amount)

  (couponProduced2, _) <- submit borrower $ exerciseCmd couponProduced Instruction.Allocate with
    actors = Set.fromList [borrower]
    allocation = Pledge (toInterfaceContractId @Holding.Base borrowerCashUsed)
  submit_ lender $ exerciseCmd couponProduced2 Instruction.Approve with
    actors = Set.fromList [lender]
    approval = TakeDelivery lenderCashAccount

  logLedger
    borrower
    (fromInterfaceContractId @B.Batch claimResult.batchCid)

  submit_ agent $ do
    exerciseCmd claimResult.batchCid Batch.Settle with
      actors = Set.fromList [agent]

  return ()
