module Scripts.Settlement where

import Daml.Script
import qualified DA.Text as T

import Daml.Finance.Interface.Holding.Base qualified as Holding (I)
import Daml.Finance.Interface.Types.Common.Types (AccountKey, Id(..), InstrumentKey(..))

import DA.Date (toDateUTC, Month(..), date, toGregorian)
import Daml.Finance.Interface.Types.Date.Calendar qualified as Cal
import Daml.Finance.Interface.Types.Date.RollConvention (Period(..), PeriodEnum(..), RollConventionEnum(..))
import Daml.Finance.Interface.Types.Date.Schedule qualified as Sched
import Daml.Finance.Interface.Types.Date.Schedule (PeriodicSchedule(..))

import Workflow.Servicing (clockUpdateEvent)
import qualified DA.Set as Set
import Daml.Finance.Lifecycle.Rule.Claim as Claim
import Daml.Finance.Interface.Lifecycle.Rule.Claim as ClaimI
--import Daml.Finance.Claims.Lifecycle.Rule as Lifecycle (Rule(..))
import qualified Daml.Finance.Interface.Lifecycle.Rule.Lifecycle as Lifecycle
import qualified Daml.Finance.Interface.Claims.Claim as C
import qualified DA.Map as Map
import DA.Time (days, time)
import Workflow.Util
import qualified Daml.Finance.Claims.Lifecycle.Rule as LifecycleRule

import Tests.Common
import Tests.IDE
import qualified Daml.Finance.Interface.Settlement.RouteProvider as RouteProvider
import qualified Daml.Finance.Settlement.RouteProvider.SingleCustodian as SingleCustodian
import qualified Daml.Finance.Interface.Settlement.Factory as Settlement
import Daml.Finance.Settlement.Factory (observers, provider, Factory(Factory))
import Daml.Finance.Interface.Lifecycle.Effect (Effect)
import Daml.Finance.Interface.Lifecycle.Rule.Lifecycle (Evolve(Evolve))
import qualified Daml.Finance.Interface.Settlement.Batch as Batch

import qualified Daml.Finance.Settlement.Batch as B
import DA.Foldable (forA_)
import qualified Daml.Finance.Interface.Settlement.Instruction as Instruction
import Daml.Finance.Interface.Settlement.Types (Allocation(Pledge))

-- | Helper container used to transfer state from one script to another.
data SettlementState = SettlementState
  with
    alice : Party
    bank : Party
    bob : Party
    public : Party
    aliceAccount : AccountKey
    bobAccount : AccountKey
    usdInstrument : InstrumentKey
    bondInstrument : InstrumentKey
    bobHoldingCid : ContractId Holding.I
  deriving (Eq, Show)

-- | Create a schedule for periodic payments.
createPaymentPeriodicSchedule : Date -> [Text] -> Cal.BusinessDayConventionEnum -> PeriodEnum ->
  Int -> Date -> Date -> PeriodicSchedule
createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod
  couponPeriodMultiplier issueDate maturityDate = do
    -- CREATE_PERIODIC_SCHEDULE_BEGIN
    let
      (y, m, d) = toGregorian firstCouponDate
      periodicSchedule = PeriodicSchedule with
        businessDayAdjustment =
          Cal.BusinessDayAdjustment with
            calendarIds = holidayCalendarIds
            convention = businessDayConvention
        effectiveDateBusinessDayAdjustment = None
        terminationDateBusinessDayAdjustment = None
        frequency =
          Sched.Periodic Sched.Frequency with
            rollConvention = DOM d
            period = Period with
              period = couponPeriod
              periodMultiplier = couponPeriodMultiplier
        effectiveDate = issueDate
        firstRegularPeriodStartDate = Some firstCouponDate
        lastRegularPeriodEndDate = Some maturityDate
        stubPeriodType = None
        terminationDate = maturityDate
    -- CREATE_PERIODIC_SCHEDULE_END
    periodicSchedule

runCreateParties : Script LedgerParties
runCreateParties = createParties

runPreOrigination : Script (LedgerParties, PreOriginationStuff)
runPreOrigination = do
  parties <- createParties
  preOrig <- preOrigination parties
  pure (parties, preOrig)

runOrigination : Script (LedgerParties, PreOriginationStuff, Origination)
runOrigination = do
  (parties, preOrig) <- runPreOrigination
  orig <- origination parties preOrig
  pure (parties, preOrig, orig)

run : Script ()
run = do
  setTime (time (date 2023 Apr 12) 4 4 4)
  p <- createParties
  po <- preOrigination p
  runBondStep p po
  return ()

-- | Test script that
-- 1. executes the `runTransfer` script
-- 2. creates a token instrument
-- 3. credits a token holding to Alice in her bank account
-- 4. atomically exchanges the token against the cash holding

runBondStep : LedgerParties -> PreOriginationStuff -> Script ()
runBondStep LedgerParties{..} PreOriginationStuff{..} = do
  {-
  -- Execute the `runTransfer` script. Bob now holds USD 1000 in his account.
  TransferState{alice
    , bank
    , bob
    , public
    , aliceAccount
    , bobAccount
    , cashInstrument = usdInstrument
    , holdingFactoryCid
    , newHoldingCid = bobHoldingCid} <- runTransfer
  -}
  -- 1. Create Route Provider
  routeProviderCid <- toInterfaceContractId @RouteProvider.I <$> submit agent_charlie do
      createCmd SingleCustodian.SingleCustodian with
        provider = agent_charlie
        observers = Set.fromList [borrower_alice, borrower_bob, lender_gary, lender_hortense]
        custodian =  agent_charlie

  -- 2. Create Settlement Factory
  settlementFactoryCid <- toInterfaceContractId @Settlement.F <$> submit agent_charlie do
    createCmd Factory with
      provider = agent_charlie
      observers = Set.fromList [borrower_bob, borrower_alice]


  orig <- origination (LedgerParties{..}) (PreOriginationStuff{..})
  now <- getTime

  result <- submit agent_charlie $ exerciseCmd (toInterfaceContractId @C.Claim orig.bond.cid) C.GetClaims with actor = agent_charlie
  debug $ show result

  let borrower = borrower_alice
      lender = lender_gary
      agent = agent_charlie
      (y',m',d') = toGregorian (toDateUTC now)
      today = date (y'+1) m' d'
      parties = Set.fromList [borrower, lender, agent]
      updateEvent = clockUpdateEvent parties parties today
  updateEventCid <- fmap toInterfaceContractId $
    submitMulti [agent,borrower,lender] [] $ do createCmd updateEvent

  lifecycleRule <- fmap (toInterfaceContractId @Lifecycle.Lifecycle) $
    submitMulti [agent, borrower] [] $ createCmd $ LifecycleRule.Rule with
      providers = Set.fromList [borrower]
      observers = Map.fromList
        [ ("borrower", Set.singleton borrower)
        , ("lender", Set.singleton lender)
        , ("agent", Set.singleton agent)
        ]
      lifecycler = agent
      id = Id "LifecycleRule"
      description = "Rule to lifecycle the bond instrument"

  claimRule <- fmap (toInterfaceContractId @ClaimI.I) $
    submit borrower_alice $ createCmd $ Claim.Rule with
      providers = Set.fromList [borrower]
      claimers = Set.singleton lender
      settlers = Set.fromList [lender, borrower, agent]
      routeProviderCid
      settlementFactoryCid
      netInstructions = False

  (newBondOpt, [effectCid]) <- submitMulti [agent, borrower] [] $
    exerciseCmd lifecycleRule Lifecycle.Evolve with
      eventCid = updateEventCid
      instrument = orig.bond.reference
      observableCids = []

  claimResult <- submitMulti [agent, borrower, lender] [] $
    exerciseCmd claimRule ClaimI.ClaimEffect with
      claimer = lender
      holdingCids = [orig.garyBondHoldingKey]
      effectCid
      batchId = Id "Loan interest payment"

  -- Allocate and Approve
  let [bondConsumed, bondProduced, couponProduced] = claimResult.instructionCids

  submit lender $ exerciseCmd bondConsumed Instruction.Allocate with
    actors = Set.fromList [lender]
    allocation = Pledge orig.garyBondHoldingKey


  batch <- queryContractId borrower_alice $ fromInterfaceContractId @B.Batch claimResult.batchCid
  case batch of
    None -> debug $ "No batch found for: " <> show claimResult.batchCid
    Some b -> displayBatch b

  -- submitMulti [agent_charlie, borrower_alice] [] do
  --   exerciseCmd claimResult.batchCid Batch.Settle with
  --     actors = Set.fromList [borrower_alice, agent_charlie]

  {-
  case newBondOpt of
    None -> debug "NO NEW STUFF"
    Some b -> debug $ show b
  -}
  return ()

displayBatch : B.Batch -> Script ()
displayBatch b = do
  debug $ b.description <> " " <> show b.id
  debug $ "> Requestors: " <> show (Set.toList  b.requestors)
  debug $ "> Settlers: " <> show (Set.toList b.settlers)
  debug $ "> Settlement time: " <> (case b.settlementTime of None -> "N/A"; Some a -> show a)
  debug $ "> Routed steps: " <> show (length b.routedStepsWithInstructionId)
  forA_ b.routedStepsWithInstructionId $ \(r, x) -> do
    debug $ ">> " <> show r.sender <> " -> "  <> show r.receiver <> " (" <> show r.quantity.amount <> " " <> show r.quantity.unit.id <> " v" <> T.take 4 r.quantity.unit.version <> ")"