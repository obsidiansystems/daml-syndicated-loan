module Scripts.Settlement where

import Daml.Script

import DA.Date (toDateUTC, Month(..), date, toGregorian)
import DA.Set qualified as Set
import DA.Time (time)

import Daml.Finance.Interface.Holding.Base qualified as Holding (I, Base)
import Daml.Finance.Interface.Lifecycle.Effect (Effect)
import Daml.Finance.Interface.Lifecycle.Rule.Claim qualified as Claim (ClaimEffect(..))
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Settle(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..))
import Daml.Finance.Interface.Types.Common.Types (AccountKey, Id(..), InstrumentKey(..))

import Daml.Finance.Settlement.Batch qualified as B

import Scripts.Parties
import Tests.Common
import Tests.Util qualified as Util
import Util.Display
import Util.Script
import Workflow.Origination
import qualified Daml.Finance.Settlement.Instruction as Settlement



-- | Helper container used to transfer state from one script to another.
data SettlementState = SettlementState
  with
    alice : Party
    bank : Party
    bob : Party
    public : Party
    aliceAccount : AccountKey
    bobAccount : AccountKey
    usdInstrument : InstrumentKey
    bondInstrument : InstrumentKey
    bobHoldingCid : ContractId Holding.I
  deriving (Eq, Show)

runCreateParties : Script LedgerParties
runCreateParties = createParties

runPreOrigination : Script (LedgerParties, PreOriginationStuff)
runPreOrigination = do
  parties <- createParties
  preOrig <- preOrigination parties
  pure (parties, preOrig)

runOrigination : Script (LedgerParties, PreOriginationStuff, Origination)
runOrigination = do
  (parties, preOrig) <- runPreOrigination
  orig <- originationStep parties preOrig
  pure (parties, preOrig, orig)

run : Script ()
run = do
  setTime (time (date 2023 Apr 12) 4 4 4)
  (p, po, o) <- runOrigination
  originationSettlement <- settleLoan p po o
  runBondStep p po o originationSettlement
  return ()

-- | Test script that
-- 1. executes the `runTransfer` script
-- 2. creates a token instrument
-- 3. credits a token holding to Alice in her bank account
-- 4. atomically exchanges the token against the cash holding

runBondStep : LedgerParties -> PreOriginationStuff -> Origination -> OriginationSettlement -> Script ()
runBondStep LedgerParties{..} PreOriginationStuff{..} orig OriginationSettlement{..} = do
  let agent = orig.origLoanAgreement.loanAgreement.agent
      now = orig.originationTime
  let (y',m',d') = toGregorian (toDateUTC now)
      today = date (y'+1) m' d'

  lifecycleData <- submit agent $ exerciseCmd orig.origLoanAgreementCid OriginatedLoanAgreement_Lifecycle with
    today

  let [effectCid] = lifecycleData.effects


  processLenderClaim $ LenderClaimConfig with
    agent
    orig
    effectCid
    borrower = borrower_alice
    lender = lender_gary
    lenderLoanAccount = ledgerAccounts.garyLoanAccount
    lenderCashAccount = ledgerAccounts.garyAccount
    borrowerCashAccount = ledgerAccounts.aliceAccount

  _resultCids <- processLenderClaim $ LenderClaimConfig with
    agent
    orig
    effectCid
    borrower = borrower_alice
    lender = lender_hortense
    lenderLoanAccount = ledgerAccounts.hortenseLoanAccount
    lenderCashAccount = ledgerAccounts.hortenseAccount
    borrowerCashAccount = ledgerAccounts.aliceAccount

  return ()

data LenderClaimConfig = LenderClaimConfig with
  orig : Origination
  effectCid : ContractId Effect
  lender : Party
  lenderLoanAccount : AccountKey
  lenderCashAccount : AccountKey
  borrower : Party
  borrowerCashAccount : AccountKey
  agent : Party

processLenderClaim : LenderClaimConfig -> Script ()
processLenderClaim LenderClaimConfig{..} = do
  Some lenderLoanHoldingCid <- Util.getHoldingOfAmount
    lenderLoanAccount
    orig.origLoanAgreement.bondKey
    None
  let lenderLoanHoldingBase = toInterfaceContractId @Holding.Base lenderLoanHoldingCid

  claimResult <- submit lender $
    exerciseCmd orig.origLoanAgreement.claimRule Claim.ClaimEffect with
      claimer = lender
      holdingCids = [lenderLoanHoldingBase]
      effectCid
      batchId = Id "Loan interest payment"

  -- Allocate and Approve
  let [bondConsumed, bondProduced, couponProduced] = claimResult.instructionCids

  (bondConsumed2, _) <- submit lender $ exerciseCmd bondConsumed Instruction.Allocate with
    actors = Set.fromList [lender]
    allocation = Pledge lenderLoanHoldingBase
  submit_ borrower $ exerciseCmd bondConsumed2 Instruction.Approve with
    actors = Set.fromList [borrower]
    approval = DebitSender

  (bondProduced2, _) <- submit borrower $ exerciseCmd bondProduced Instruction.Allocate with
    actors = Set.fromList [borrower]
    allocation = CreditReceiver
  submit_ lender $ exerciseCmd bondProduced2 Instruction.Approve with
    actors = Set.fromList [lender]
    approval = TakeDelivery lenderLoanAccount

  Some couponProducedInstr <- queryContractId borrower (fromInterfaceContractId @Settlement.Instruction couponProduced)
  Some borrowerCashUsed <- Util.getHoldingOfAmount
    borrowerCashAccount
    couponProducedInstr.routedStep.quantity.unit
    (Some couponProducedInstr.routedStep.quantity.amount)

  (couponProduced2, _) <- submit borrower $ exerciseCmd couponProduced Instruction.Allocate with
    actors = Set.fromList [borrower]
    allocation = Pledge (toInterfaceContractId @Holding.Base borrowerCashUsed)
  submit_ lender $ exerciseCmd couponProduced2 Instruction.Approve with
    actors = Set.fromList [lender]
    approval = TakeDelivery lenderCashAccount

  logLedger
    borrower
    ("No batch found for: " <> show claimResult.batchCid)
    (fromInterfaceContractId @B.Batch claimResult.batchCid)

  submit_ agent $ do
    exerciseCmd claimResult.batchCid Batch.Settle with
      actors = Set.fromList [agent]

  return ()