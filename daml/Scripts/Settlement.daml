module Scripts.Settlement where

import Daml.Script

import DA.Date (toDateUTC, Month(..), date, toGregorian)
import DA.Set qualified as Set
import DA.Time (time)

import Daml.Finance.Interface.Holding.Base qualified as Holding (Base)
import Daml.Finance.Interface.Lifecycle.Effect (Effect)
import Daml.Finance.Interface.Lifecycle.Rule.Claim qualified as Claim (ClaimEffect(..))
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Settle(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..))
import Daml.Finance.Interface.Types.Common.Types (AccountKey, Id(..), InstrumentKey(..))
import Daml.Finance.Settlement.Instruction qualified as Settlement
import Daml.Finance.Settlement.Batch qualified as B

import Scripts.Origination
import Scripts.Origination.Settlement
import Scripts.Parties
import Scripts.PreOrigination
import Tests.Util qualified as Util
import Util.Display
import Util.Script
import Workflow.Origination

-- | Helper container used to transfer state from one script to another.
data SettlementState = SettlementState
  with
    alice : Party
    bank : Party
    bob : Party
    public : Party
    aliceAccount : AccountKey
    bobAccount : AccountKey
    usdInstrument : InstrumentKey
    bondInstrument : InstrumentKey
  deriving (Eq, Show)

runCreateParties : Script LedgerParties
runCreateParties = createParties

runPreOrigination : Script (LedgerParties, PreOrigination)
runPreOrigination = do
  parties <- createParties
  preOrig <- preOrigination parties
  pure (parties, preOrig)

runOrigination : Script (LedgerParties, PreOrigination, Origination)
runOrigination = do
  (parties, preOrig) <- runPreOrigination
  orig <- originate parties preOrig
  pure (parties, preOrig, orig)

run : Script ()
run = do
  setTime (time (date 2023 Apr 12) 4 4 4)
  (p, po, o) <- runOrigination
  settleLoan p po o
  let startTime = o.originationTime
      (y',m',d') = toGregorian (toDateUTC startTime)
      agent = o.origLoanAgreement.loanAgreement.agent
  Some origLoanAgreementCid1 <- runBondStep p po agent o.origLoanAgreementCid $ date (y'+1) m' d'
  Some _origLoanAgreementCid2 <- runBondStep p po agent origLoanAgreementCid1 $ date (y'+2) m' d'
  return ()

-- | Test script that
-- 1. executes the `runTransfer` script
-- 2. creates a token instrument
-- 3. credits a token holding to Alice in her bank account
-- 4. atomically exchanges the token against the cash holding

runBondStep : LedgerParties -> PreOrigination -> Party -> ContractId OriginatedLoanAgreement -> Date -> Script (Optional (ContractId OriginatedLoanAgreement))
runBondStep LedgerParties{..} PreOrigination{..} agent origLoanAgreementCid today = do
  Some origLoanAgreement <- queryContractId agent origLoanAgreementCid

  (newOrigLoanAgreement, [effectCid]) <- submit agent $ exerciseCmd origLoanAgreementCid OriginatedLoanAgreement_Lifecycle with
    today

  processLenderClaim $ LenderClaimConfig with
    agent
    origLoanAgreement
    effectCid
    bondKey = origLoanAgreement.bondKey
    borrower = borrower_alice
    lender = lender_gary
    lenderLoanAccount = ledgerAccounts.garyLoanAccount
    lenderCashAccount = ledgerAccounts.garyAccount
    borrowerCashAccount = ledgerAccounts.aliceAccount

  _resultCids <- processLenderClaim $ LenderClaimConfig with
    agent
    origLoanAgreement
    effectCid
    bondKey = origLoanAgreement.bondKey
    borrower = borrower_alice
    lender = lender_hortense
    lenderLoanAccount = ledgerAccounts.hortenseLoanAccount
    lenderCashAccount = ledgerAccounts.hortenseAccount
    borrowerCashAccount = ledgerAccounts.aliceAccount

  return newOrigLoanAgreement

data LenderClaimConfig = LenderClaimConfig with
  origLoanAgreement : OriginatedLoanAgreement
  effectCid : ContractId Effect
  bondKey : InstrumentKey
  lender : Party
  lenderLoanAccount : AccountKey
  lenderCashAccount : AccountKey
  borrower : Party
  borrowerCashAccount : AccountKey
  agent : Party

processLenderClaim : LenderClaimConfig -> Script ()
processLenderClaim LenderClaimConfig{..} = do
  Some lenderLoanHoldingCid <- Util.getHoldingOfAmount
    lenderLoanAccount
    bondKey
    None
  let lenderLoanHoldingBase = toInterfaceContractId @Holding.Base lenderLoanHoldingCid

  claimResult <- submit lender $
    exerciseCmd origLoanAgreement.claimRule Claim.ClaimEffect with
      claimer = lender
      holdingCids = [lenderLoanHoldingBase]
      effectCid
      batchId = Id "Loan interest payment"

  -- Allocate and Approve
  let [bondConsumed, bondProduced, couponProduced] = claimResult.instructionCids

  (bondConsumed2, _) <- submit lender $ exerciseCmd bondConsumed Instruction.Allocate with
    actors = Set.fromList [lender]
    allocation = Pledge lenderLoanHoldingBase
  submit_ borrower $ exerciseCmd bondConsumed2 Instruction.Approve with
    actors = Set.fromList [borrower]
    approval = DebitSender

  (bondProduced2, _) <- submit borrower $ exerciseCmd bondProduced Instruction.Allocate with
    actors = Set.fromList [borrower]
    allocation = CreditReceiver
  submit_ lender $ exerciseCmd bondProduced2 Instruction.Approve with
    actors = Set.fromList [lender]
    approval = TakeDelivery lenderLoanAccount

  Some couponProducedInstr <- queryContractId borrower (fromInterfaceContractId @Settlement.Instruction couponProduced)
  Some borrowerCashUsed <- Util.getHoldingOfAmount
    borrowerCashAccount
    couponProducedInstr.routedStep.quantity.unit
    (Some couponProducedInstr.routedStep.quantity.amount)

  (couponProduced2, _) <- submit borrower $ exerciseCmd couponProduced Instruction.Allocate with
    actors = Set.fromList [borrower]
    allocation = Pledge (toInterfaceContractId @Holding.Base borrowerCashUsed)
  submit_ lender $ exerciseCmd couponProduced2 Instruction.Approve with
    actors = Set.fromList [lender]
    approval = TakeDelivery lenderCashAccount

  logLedger
    borrower
    (fromInterfaceContractId @B.Batch claimResult.batchCid)

  submit_ agent $ do
    exerciseCmd claimResult.batchCid Batch.Settle with
      actors = Set.fromList [agent]

  return ()
