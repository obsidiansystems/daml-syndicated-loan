module Tests.Common where

{-
  ALL Functions in the file should have a type signature of LedgerParties -> Script a, this is because
  DAML Hub cannot create parties via DAML Scripts. The local LSP can, but we want to be able to test
  against a live non-stateless ledger
-}

import DA.Map (empty, fromList)
import DA.Set (singleton)
import Daml.Script
import Daml.Finance.Interface.Types.Common.Types
import Workflow.CreateAccount qualified as CreateAccount
import Workflow.CreditAccount qualified as CreditAccount
import Daml.Finance.Interface.Account.Factory qualified as Account (F)
import Daml.Finance.Interface.Holding.Factory qualified as Holding (F)
import Daml.Finance.Account.Account qualified as Account (Factory(..))
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory(..))
import DA.Foldable

import Workflow.Origination

-- | Parties representing various agents in the syndicated loan workflow
-- Each type of agent has two representatives so that we can test disclosure
-- and divulgence.
data LedgerParties = LedgerParties with
    borrower_alice : Party
    borrower_bob : Party
    agent_charlie : Party
    agent_debbie : Party
    underwriter_emma : Party
    underwriter_fred : Party
    lender_gary : Party
    lender_hortense : Party
    fed_ingrid : Party
  deriving (Show, Eq, Ord)

initialTest : LedgerParties -> Script ()
initialTest parties = do
  stuff <- preOrigination parties
  loan <- origination parties stuff
  servicing parties loan

data PreOriginationStuff = PreOriginationStuff with
  aliceAccount : AccountKey

-- Pre-origination
preOrigination : LedgerParties -> Script PreOriginationStuff
preOrigination LedgerParties{..} = do
    -- Create the Fed

    -- Create USD
    let instrumentId = Id "USD"
        instrumentVersion = "0"
        usdInstrument = InstrumentKey with
          issuer = fed_ingrid
          depository = fed_ingrid
          id = instrumentId
          version = instrumentVersion

    -- Create USD Accounts for Banks and Companies
    accountFactoryCid <- toInterfaceContractId @Account.F <$> submit fed_ingrid do
      createCmd Account.Factory with provider = fed_ingrid; observers = empty

    holdingFactoryCid <- toInterfaceContractId @Holding.F <$> submit fed_ingrid do
      createCmd Fungible.Factory with
        provider = fed_ingrid
        observers = empty -- fromList [("PublicObserver", singleton public )]

    -- ...for Hortenses's Bank
    hortenseRequestCid <- submit lender_hortense do
      createCmd CreateAccount.Request with owner = lender_hortense; custodian = fed_ingrid
    hortenseAccount <- submit fed_ingrid do
      exerciseCmd hortenseRequestCid CreateAccount.Accept with
        label = "Hortense@Bank"
        description = "Account of Hortense at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid = holdingFactoryCid
        observers = []

    -- allocate funds to Hortense
    hortenseRequestCid <- submit lender_hortense do
      createCmd CreditAccount.Request with
        account = hortenseAccount
        instrument = InstrumentKey with
          issuer = fed_ingrid
          depository = fed_ingrid
          id = instrumentId
          version = instrumentVersion
        amount = 100_000_000.00

    hortenseCashHoldingCid <- submit fed_ingrid do exerciseCmd hortenseRequestCid CreditAccount.Accept

    -- ...for Gary's Bank
    garyRequestCid <- submit lender_gary do
      createCmd CreateAccount.Request with owner = lender_gary; custodian = fed_ingrid
    garyAccount <- submit fed_ingrid do
      exerciseCmd garyRequestCid CreateAccount.Accept with
        label = "Gary@Bank"
        description = "Account of Bob at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid = holdingFactoryCid
        observers = []

    -- allocate funds to Gary
    garyRequestCid <- submit lender_gary do
      createCmd CreditAccount.Request with
        account = garyAccount
        instrument = InstrumentKey with
          issuer = fed_ingrid
          depository = fed_ingrid
          id = instrumentId
          version = instrumentVersion
        amount = 50_000_000.00

    garyCashHoldingCid <- submit fed_ingrid do exerciseCmd garyRequestCid CreditAccount.Accept

    -- ...for Bob's Company
    bobRequestCid <- submit borrower_bob do
      createCmd CreateAccount.Request with owner = borrower_bob; custodian = fed_ingrid
    bobAccount <- submit fed_ingrid do
      exerciseCmd bobRequestCid CreateAccount.Accept with
        label = "Bob@Fed"
        description = "Account of Bob at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid = holdingFactoryCid
        observers = []

    -- ...for Alice's Company
    aliceRequestCid <- submit borrower_alice do
      createCmd CreateAccount.Request with owner = borrower_alice; custodian = fed_ingrid
    aliceAccount <- submit fed_ingrid do
      exerciseCmd aliceRequestCid CreateAccount.Accept with
        label = "Alice@Bank"
        description = "Account of Alice at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid = holdingFactoryCid
        observers = []

    return $ PreOriginationStuff with
      aliceAccount

origination : LedgerParties -> PreOriginationStuff -> Script (ContractId LoanAgreement)
origination LedgerParties{..} PreOriginationStuff{..} = do
  let amount = 10_000_000.00
  application <- submit borrower_alice $ makeLoanApplication amount
  underwritingRequest <- submit agent_charlie makeUnderwritingRequest
  underwritingResult <- submit underwriter_emma $ makeUnderwritingResult underwritingRequest
  let possibleLenders = [lender_gary, lender_hortense]
  forA_ possibleLenders $ \lender -> do
    submit agent_charlie $ makeFundingRequest underwritingResult lender
  fundingInterestCids <- forA possibleLenders $ \lender -> do
    [(fundingRequestCid, fundingRequest)] <- getFundingRequestsFor lender
    submit lender $ makeFundingInterest fundingRequestCid fundingRequest [(10_000_000.00, 5.0)]
  fundingInterests <- forA fundingInterestCids $ \cid -> do
    Some fundingInterest <- queryContractId agent_charlie cid
    pure (cid, fundingInterest)
  (rate, selectedFundingInterests) <- selectFundingInterests fundingInterests
  loanProposal <- submit agent_charlie $ createLoanProposal borrower_alice amount rate
  acceptedLoan <- submit borrower_alice $ acceptLoanProposal loanProposal
  submit agent_charlie $ createFinalLoan acceptedLoan selectedFundingInterests

type Amount = Numeric 2
type Rate = Decimal

makeUnderwritingResult : ContractId UnderwritingRequest -> Commands (ContractId UnderwritingResult)
makeUnderwritingResult = undefined

makeFundingRequest : ContractId UnderwritingResult -> Party -> Commands (ContractId FundingRequest)
makeFundingRequest = undefined

getFundingRequestsFor : Party -> Script [(ContractId FundingRequest, FundingRequest)]
getFundingRequestsFor = undefined

makeLoanApplication : Amount -> Commands (ContractId LoanApplication)
makeLoanApplication = undefined

makeUnderwritingRequest : Commands (ContractId UnderwritingRequest)
makeUnderwritingRequest = undefined

selectFundingInterests : [(ContractId FundingInterest, FundingInterest)] -> Script (Rate, [(ContractId FundingInterest, Amount)])
selectFundingInterests = undefined

createFinalLoan : ContractId AcceptedLoan -> [(ContractId FundingInterest, Amount)] -> Commands (ContractId LoanAgreement)
createFinalLoan = undefined

createLoanProposal : Party -> Amount -> Rate -> Commands (ContractId LoanProposal)
createLoanProposal = undefined

acceptLoanProposal : ContractId LoanProposal -> Commands (ContractId AcceptedLoan)
acceptLoanProposal = undefined

makeFundingInterest : ContractId FundingRequest -> FundingRequest -> [(Amount, Rate)] -> Commands (ContractId FundingInterest)
makeFundingInterest = undefined

servicing : LedgerParties -> ContractId LoanAgreement -> Script ()
servicing LedgerParties{..} loan = do
  pure ()
