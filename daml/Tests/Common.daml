module Tests.Common where

{-
  ALL Functions in the file should have a type signature of LedgerParties -> Script a, this is because
  DAML Hub cannot create parties via DAML Scripts. The local LSP can, but we want to be able to test
  against a live non-stateless ledger
-}

import DA.Action
import DA.Map (empty)
import qualified DA.Map as Map
import Daml.Script
import Daml.Finance.Interface.Types.Common.Types
import Workflow.CreateAccount qualified as CreateAccount
import Workflow.CreditAccount qualified as CreditAccount
import Workflow.Transfer qualified as Transfer
import Daml.Finance.Interface.Account.Factory qualified as Account (F)
import Daml.Finance.Interface.Holding.Factory qualified as Holding (F)
import Daml.Finance.Account.Account qualified as Account (Factory(..))
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory (..))
import DA.Foldable

import Workflow.Origination

import qualified Daml.Finance.Interface.Settlement.RouteProvider as RouteProvider
import qualified Daml.Finance.Settlement.RouteProvider.SingleCustodian as SingleCustodian
import qualified DA.Set as S

import qualified Daml.Finance.Interface.Settlement.Factory as Settlement
import Daml.Finance.Settlement.Factory (Factory(..))

import Daml.Finance.Interface.Settlement.Batch qualified as Batch (I)
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (I)
import Daml.Finance.Interface.Settlement.Types (Step(..))
import DA.Set (singleton)
import Daml.Finance.Interface.Holding.Transferable (Transfer)
import qualified Daml.Finance.Holding.Fungible as FungibleX
import qualified Daml.Finance.Interface.Holding.Fungible as Fungible
import Daml.Finance.Interface.Instrument.Base.Instrument (exerciseInterfaceByKey)
import Daml.Finance.Interface.Holding.Fungible (SplitResult(SplitResult))

-- | Parties representing various agents in the syndicated loan workflow
-- Each type of agent has two representatives so that we can test disclosure
-- and divulgence.
data LedgerParties = LedgerParties with
    borrower_alice : Party
    borrower_bob : Party
    agent_charlie : Party
    agent_debbie : Party
    underwriter_emma : Party
    underwriter_fred : Party
    lender_gary : Party
    lender_hortense : Party
    fed_ingrid : Party
  deriving (Show, Eq, Ord)

perfTest : LedgerParties -> Script ()
perfTest parties = do
  let LedgerParties{..} = parties
      instrumentId = Id "USD"
      instrumentVersion = "0"
      usdInstrument = InstrumentKey with
        issuer = fed_ingrid
        depository = fed_ingrid
        id = instrumentId
        version = instrumentVersion
  accountkeys <- createAccounts parties
  pure ()


--createAccounts : LedgerParties -> Script [AccountKey]
createAccounts LedgerParties{..} = do
    let instrumentId = Id "USD"
        instrumentVersion = "0"
        usdInstrument = InstrumentKey with
          issuer = fed_ingrid
          depository = fed_ingrid
          id = instrumentId
          version = instrumentVersion

    accountFactoryCid <- toInterfaceContractId @Account.F <$> submit fed_ingrid do
      createCmd Account.Factory with provider = fed_ingrid; observers = empty

    holdingFactoryCid <- toInterfaceContractId @Holding.F <$> submit fed_ingrid do
      createCmd Fungible.Factory with
        provider = fed_ingrid
        observers = empty
    aliceReq <- submit borrower_alice do
      createCmd CreateAccount.Request with owner = borrower_alice; custodian = fed_ingrid
    aliceAccount <- submit fed_ingrid do
      exerciseCmd aliceReq CreateAccount.Accept with
        label = "Alice@Fed"
        description = "null"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid
        observers = []

    accountkeys <- forA [1..100] $ \x -> do
      requestCid <- submit lender_hortense do
        createCmd CreateAccount.Request with owner = lender_hortense; custodian = fed_ingrid
      c <- submit fed_ingrid $ do
        exerciseCmd requestCid CreateAccount.Accept with
          label = (show x)
          description = "null"
          accountFactoryCid
          holdingFactoryCid
          observers = [borrower_alice]
      requestMon <- submit borrower_alice do
        createCmd CreditAccount.Request with
          account = aliceAccount
          instrument = InstrumentKey with
            issuer = fed_ingrid
            depository = fed_ingrid
            id = instrumentId
            version = instrumentVersion
          amount = 10000.0
      x <- submit fed_ingrid do exerciseCmd requestMon CreditAccount.Accept
      pure (c, x)
    
    forA_ (accountkeys) $ \(a, vv) -> do
      b <- submit lender_hortense $ do
        createCmd Transfer.Request with 
          receiverAccount = a
          instrument = usdInstrument
          currentOwner = borrower_alice
          amount = 10000.0
      submit borrower_alice $ exerciseCmd b Transfer.Accept with
        holdingCid = vv

initialTest : LedgerParties -> Script ()
initialTest parties = do
  stuff <- preOrigination parties
  loan <- origination parties stuff
  servicing parties loan

data PreOriginationStuff = PreOriginationStuff with
  usdInstrument : InstrumentKey
  ledgerAccounts : LedgerAccounts

data LedgerAccounts = LedgerAccounts with
    aliceAccount : AccountKey
    bobAccount : AccountKey
    charlieAccount : AccountKey
    debbieAccount : AccountKey
    garyAccount : AccountKey
    hortenseAccount : AccountKey
  deriving (Show, Eq, Ord)

-- Pre-origination
preOrigination : LedgerParties -> Script PreOriginationStuff
preOrigination LedgerParties{..} = do
    -- Create the Fed

    -- Create USD
    let instrumentId = Id "USD"
        instrumentVersion = "0"
        usdInstrument = InstrumentKey with
          issuer = fed_ingrid
          depository = fed_ingrid
          id = instrumentId
          version = instrumentVersion

    -- Create USD Accounts for Banks and Companies
    accountFactoryCid <- toInterfaceContractId @Account.F <$> submit fed_ingrid do
      createCmd Account.Factory with provider = fed_ingrid; observers = empty

    holdingFactoryCid <- toInterfaceContractId @Holding.F <$> submit fed_ingrid do
      createCmd Fungible.Factory with
        provider = fed_ingrid
        observers = empty -- fromList [("PublicObserver", singleton public )] -- TODO: Probably wont need this

    -- ...for Hortenses's Bank
    hortenseRequestCid <- submit lender_hortense do
      createCmd CreateAccount.Request with owner = lender_hortense; custodian = fed_ingrid

    hortenseAccount <- submit fed_ingrid do
      exerciseCmd hortenseRequestCid CreateAccount.Accept with
        label = "Hortense@Bank"
        description = "Account of Hortense at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid = holdingFactoryCid
        observers = []

    -- allocate funds to Hortense
    hortenseRequestCid <- submit lender_hortense do
      createCmd CreditAccount.Request with
        account = hortenseAccount
        instrument = usdInstrument
        amount = 100_000_000.00

    hortenseCashHoldingCid <- submit fed_ingrid do exerciseCmd hortenseRequestCid CreditAccount.Accept

    -- ...for Gary's Bank
    garyRequestCid <- submit lender_gary do
      createCmd CreateAccount.Request with owner = lender_gary; custodian = fed_ingrid
    garyAccount <- submit fed_ingrid do
      exerciseCmd garyRequestCid CreateAccount.Accept with
        label = "Gary@Bank"
        description = "Account of Bob at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid = holdingFactoryCid
        observers = []

    -- allocate funds to Gary
    garyRequestCid <- submit lender_gary do
      createCmd CreditAccount.Request with
        account = garyAccount
        instrument = usdInstrument
        amount = 50_000_000.00

    garyCashHoldingCid <- submit fed_ingrid do exerciseCmd garyRequestCid CreditAccount.Accept

    -- ...for Bob's Company
    bobRequestCid <- submit borrower_bob do
      createCmd CreateAccount.Request with owner = borrower_bob; custodian = fed_ingrid
    bobAccount <- submit fed_ingrid do
      exerciseCmd bobRequestCid CreateAccount.Accept with
        label = "Bob@Fed"
        description = "Account of Bob at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid = holdingFactoryCid
        observers = []

    -- ...for Alice's Company
    aliceRequestCid <- submit borrower_alice do
      createCmd CreateAccount.Request with owner = borrower_alice; custodian = fed_ingrid
    aliceAccount <- submit fed_ingrid do
      exerciseCmd aliceRequestCid CreateAccount.Accept with
        label = "Alice@Bank"
        description = "Account of Alice at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid = holdingFactoryCid
        observers = []
    
    -- ...for Charlie's agency
    charlieRequestCid <- submit agent_charlie do
      createCmd CreateAccount.Request with owner = agent_charlie; custodian = fed_ingrid
    charlieAccount <- submit fed_ingrid do
      exerciseCmd charlieRequestCid CreateAccount.Accept with
        label = "Charlie@Bank"
        description = "Account of Charlie at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid = holdingFactoryCid
        observers = []

    -- ...for Debbie's agency
    debbieRequestCid <- submit agent_debbie do
      createCmd CreateAccount.Request with owner = agent_debbie; custodian = fed_ingrid
    debbieAccount <- submit fed_ingrid do
      exerciseCmd debbieRequestCid CreateAccount.Accept with
        label = "Debbie@Bank"
        description = "Account of Debbie at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid = holdingFactoryCid
        observers = []

    let ledgerAccounts = LedgerAccounts with ..
    return $ PreOriginationStuff with
      usdInstrument
      ledgerAccounts

origination : LedgerParties -> PreOriginationStuff -> Script (ContractId LoanAgreement)
origination LedgerParties{..} PreOriginationStuff{..} = do
  let amount = 10_000_000.00
      rate = RatePerAnnum 0.05 -- 5% per annum
      uuid = "golden"
      loanApplication = LoanApplication with
        borrower = borrower_alice
        agent = agent_charlie
        instrument = usdInstrument
        amount
        maxInterestRate = rate
        prospectus = "To test the syndicated loans framework :)"
        durationYears = 10
  -- Borrower submits an application for a loan
  application <- submit borrower_alice $ createCmd loanApplication
  -- Agent coordinating the lending first asks an underwriter for a report
  underwritingRequest <- submit agent_charlie (makeUnderwritingRequest underwriter_emma uuid application)
  underwritingResult <- makeUnderwritingResult underwriter_emma underwritingRequest
  -- Agent with underwriter's report in hand reaches out to possible lenders
  let possibleLenders = [lender_gary, lender_hortense]
  forA_ possibleLenders $ \lender -> do
    makeFundingRequest agent_charlie amount underwritingResult lender
  -- Lenders make their offers
  -- TODO: Lenders declining to make an offer
  fundingInterestCids <- forA possibleLenders $ \lender -> do
    [(fundingRequestCid, fundingRequest)] <- getFundingRequestsFor lender
    submit lender $ makeFundingInterest lender fundingRequestCid (amount, rate)
  fundingInterests <- forA fundingInterestCids $ \cid -> do
    Some fundingInterest <- queryContractId agent_charlie cid
    pure (cid, fundingInterest)
  -- Agent takes all lending offers and constructs a loan offer for the borrower to consider
  (rate, selectedFundingInterests) <- selectFundingInterests fundingInterests
  loanProposal <- submit agent_charlie $ createLoanProposal application uuid rate
  acceptedLoan <- acceptLoanProposal borrower_alice loanProposal
  -- Now that all parties have agreed to their individual terms, the agent constructs the final loan agreement
  -- and gathers the signatures that have been authorized.
  pendingAgreement <- createPendingLoanAgreement agent_charlie acceptedLoan selectedFundingInterests
  borrowerSigned <- submit agent_charlie $ do
    exerciseCmd acceptedLoan $ AcceptedLoan_SignAgreement with
      agreementCid = pendingAgreement
  lendersSigned <- foldlA
    (\agreementCid fundingInterestCid -> submit agent_charlie $ exerciseCmd fundingInterestCid FundingInterest_SignAgreement with agreementCid)
    borrowerSigned
    selectedFundingInterests
  -- Agent constructs the final, fully signed loan agreement— ready for settlement
  submit agent_charlie $ exerciseCmd lendersSigned PendingLoanAgreement_Finalize

type Amount = Numeric 2

makeUnderwritingResult
    : Party
    -> ContractId UnderwritingRequest
    -> Script (ContractId UnderwritingResult)
makeUnderwritingResult underwriter requestCid = do
    submit underwriter $ exerciseCmd requestCid CreateUnderwritingResult with
      result = True

makeFundingRequest
    : Party
    -> Numeric 2
    -> ContractId UnderwritingResult
    -> Party
    -> Script (ContractId FundingRequest)
makeFundingRequest agent amount underwriteCid lender = do
    Some underwrite <- queryContractId agent underwriteCid
    disclosedUnderwriting <- submit agent $ exerciseCmd underwriteCid UnderwritingResult_Disclose with
        disclose_to = lender
    submit agent $ createCmd FundingRequest with
        agent
        uuid = "golden" -- TODO: Thread these through
        underwrite = disclosedUnderwriting
        participant = lender
        totalApplicationAmount = amount

getFundingRequestsFor : Party -> Script [(ContractId FundingRequest, FundingRequest)]
getFundingRequestsFor lender = query @FundingRequest lender

-- TODO: Actually make a decision about amount and rate
makeFundingInterest : Party -> ContractId FundingRequest -> (Amount, RatePerAnnum) -> Commands (ContractId FundingInterest)
makeFundingInterest lender requestCid (amount, rate) = exerciseCmd requestCid FundingRequest_Respond with
    amount
    rate

makeUnderwritingRequest : Party -> Text -> ContractId LoanApplication -> Commands (ContractId UnderwritingRequest)
makeUnderwritingRequest underwriter uuid applicationCid = exerciseCmd applicationCid LoanApplication_CreateUnderwritingRequest with
  underwriter
  uuid

-- TODO: combine the list of FundingInterest instead of just taking the first element
selectFundingInterests : [(ContractId FundingInterest, FundingInterest)] -> Script (RatePerAnnum, [ContractId FundingInterest])
selectFundingInterests ((offerCid, offer)::interests) = pure (offer.rate, [offerCid])
selectFundingInterests [] = fail "No interests to fund loan"

createPendingLoanAgreement : Party -> ContractId AcceptedLoan -> [ContractId FundingInterest] -> Script (ContractId PendingLoanAgreement)
createPendingLoanAgreement agent acceptanceCid fundingCids = do
  Some acceptance <- queryContractId agent acceptanceCid
  lendersWithAmounts <- forA fundingCids $ \offerCid -> do
    Some loanOffer <- queryContractId agent offerCid
    pure (loanOffer.participant, loanOffer.amount)
  let agreement = LoanAgreement with
        agent
        participantsWithAmounts = Map.fromList lendersWithAmounts
        borrower = acceptance.borrower
        uuid = "golden" -- TODO: Thread these through
        prospectus = "uhhh" -- TODO: Get this
        loanTerms = LoanTerms with
          instrument = acceptance.instrument
          amount = acceptance.amount
          rate = acceptance.rate
          durationYears = 10 -- TODO: Get this

  submit agent $ createCmd PendingLoanAgreement with
    agreement
    signed = []

createLoanProposal : ContractId LoanApplication -> Text -> RatePerAnnum -> Commands (ContractId SyndicatedLoanOffer)
createLoanProposal applicationCid uuid rate = exerciseCmd applicationCid LoanApplication_CreateOffer with
  uuid
  rate

acceptLoanProposal : Party -> ContractId SyndicatedLoanOffer -> Script (ContractId AcceptedLoan)
acceptLoanProposal borrower offerCid = do
  submit borrower $ exerciseCmd offerCid SyndicatedLoanOffer_Accept

-- TODO: This will take a LoanAgreement once we have multi-party signing implemented
servicing : LedgerParties -> ContractId LoanAgreement -> Script ()
servicing LedgerParties{..} loan = do
  pure ()

settleLoan : LedgerParties -> LoanAgreement -> Script ()
settleLoan LedgerParties {..} loanAgreement = do
  -- 1. Create Route Provider
  routeProviderCid <- toInterfaceContractId @RouteProvider.I <$> submit fed_ingrid do
      createCmd SingleCustodian.SingleCustodian with
        provider = fed_ingrid
        observers = S.fromList [borrower_alice, borrower_bob]
        custodian = fed_ingrid

  -- 2. Create Settlement Factory
  settlementFactoryCid <- toInterfaceContractId @Settlement.F <$> submit fed_ingrid do
    createCmd Factory with
      provider = fed_ingrid
      observers = S.fromList [borrower_bob, borrower_alice]

  -- TODO: This is the part where you begin to construct
  -- 1: All lenders send funds to Agent
  -- 2: Agent sends funds to borrower

  settlementProposalCid <- submit agent_charlie do
    createCmd SettlementProposal with
      loan = loanAgreement
      sigAccumulator = []
      routeProviderCid
      settlementFactoryCid

  -- (batchCid, recSettleInstructionCid, paySettleInstructionCid) <- submit borrower_alice do
  --   exerciseCmd settlementProposalCid Accept_Borrower
  settlementRes <- submit borrower_alice do
    exerciseCmd settlementProposalCid Accept_Borrower

  return ()

template SettlementProposal
  with
    loan : LoanAgreement
    sigAccumulator: [Party] -- Acquire acceptance from all parties
    routeProviderCid : ContractId RouteProvider.I
    settlementFactoryCid : ContractId Settlement.F
  where
    signatory loan.agent
    observer loan.borrower::(map fst $ Map.toList loan.participantsWithTerms)
    choice Accept_Borrower : Optional (ContractId Batch.I, ContractId Instruction.I, ContractId Instruction.I)
      controller loan.borrower
      do
        let lendersAndBorrowers = loan.borrower::(map fst $ Map.toList loan.participantsWithTerms)
            id = "settlement-" <> (show settlementFactoryCid) <> "-" <> (show routeProviderCid)
        if sigAccumulator == lendersAndBorrowers then do
          -- TODO: DRY
          -- Settlement of lenders
          let lenderSteps = fmap loan.participantsWithTerms $ \(lender, investAmount) ->
                Step with sender = lender; receiver = loan.agent; quantity = investAmount
          -- Settlement of borrower
              borrowerStep =
                Step with sender = loan.agent; receiver = loan.borrower; quantity = loan.loanTerms.amount

          -- Discover settlement routes for the steps
          routedSteps <- exercise routeProviderCid RouteProvider.Discover with
            discoverors = Map.fromList $ loan.agent::lendersAndBorrowers
            contextId = None
            steps = borrowerStep::lenderSteps

          -- Instruct settlement
          (containerCid, [recInstructionCid, payInstructionCid]) <-
            exercise settlementFactoryCid Settlement.Instruct with
              instructors = Map.fromList $ loan.agent::lendersAndBorrowers
              settlers = singleton loan.agent
              id = Id id
              description = "Settlement for " <> id
              contextId = None
              routedSteps
              settlementTime = None -- i.e., immediate settlement

          return $ Some (containerCid, recInstructionCid, payInstructionCid)

        else do
          create this with sigAccumulator = loan.borrower::sigAccumulator
          return None
    choice Accept_Lender : Optional (ContractId Batch.I, ContractId Instruction.I, ContractId Instruction.I)
      controller (map fst $ Map.toList loan.participantsWithAmount)
      do
        let lendersAndBorrowers = loan.borrower::(map fst $ Map.toList loan.participantsWithAmount)
        if sigAccumulator == loan.borrower::(map fst $ Map.toList loan.participantsWithAmount) then do
          -- TODO: DRY
          -- Settlement of lenders
          let lenderSteps = fmap loan.participantsWithAmount $ \(lender, investAmount) ->
                Step with sender = lender; receiver = loan.agent; quantity = investAmount
          -- Settlement of borrower
              borrowerStep =
                Step with sender = loan.agent; receiver = loan.borrower; quantity = loan.loanTerms.amount

          -- Discover settlement routes for the steps
          routedSteps <- exercise routeProviderCid RouteProvider.Discover with
            discoverors = Map.fromList $ loan.agent::lendersAndBorrowers
            contextId = None
            steps = borrowerStep::lenderSteps

          -- Instruct settlement
          (containerCid, [recInstructionCid, payInstructionCid]) <-
            exercise settlementFactoryCid Settlement.Instruct with
              instructors = Map.fromList $ loan.agent::lendersAndBorrowers
              settlers = singleton loan.agent
              id = Id id
              description = "Settlement for " <> id
              contextId = None
              routedSteps
              settlementTime = None -- i.e., immediate settlement

          return $ Some (containerCid, recInstructionCid, payInstructionCid)

        -- add the current choice controller to the list of acquired signatures
        else do
          create this with sigAccumulator = choiceController::sigAccumulator
          return None

    choice Decline : ()
      -- ^ Decline the request.
      controller loan.borrower -- TODO: Lenders should be allowed to decline
      do pure ()

    choice Withdraw : ()
      -- ^ Withdraw the request.
      controller loan.agent
      do pure ()