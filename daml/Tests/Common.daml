module Tests.Common where

{-
  ALL Functions in the file should have a type signature of LedgerParties -> Script a, this is because
  DAML Hub cannot create parties via DAML Scripts. The local LSP can, but we want to be able to test
  against a live non-stateless ledger
-}

import DA.Map (empty)
import qualified DA.Map as Map
import Daml.Script
import Daml.Finance.Interface.Types.Common.Types
import Workflow.CreateAccount qualified as CreateAccount
import Workflow.CreditAccount qualified as CreditAccount
import Daml.Finance.Interface.Account.Factory qualified as Account (F)
import Daml.Finance.Interface.Holding.Factory qualified as Holding (F)
import Daml.Finance.Account.Account qualified as Account (Factory(..))
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory(..))
import DA.Foldable

import Workflow.Origination
import qualified Daml.Finance.Interface.Settlement.RouteProvider as RouteProvider
import qualified Daml.Finance.Settlement.RouteProvider.SingleCustodian as SingleCustodian
import qualified DA.Set as S

import qualified Daml.Finance.Interface.Settlement.Factory as Settlement
import Daml.Finance.Settlement.Factory (Factory(..))

import Daml.Finance.Interface.Settlement.Batch qualified as Batch (I)
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (I)
import Daml.Finance.Interface.Settlement.Types (Step(..))

-- | Parties representing various agents in the syndicated loan workflow
-- Each type of agent has two representatives so that we can test disclosure
-- and divulgence.
data LedgerParties = LedgerParties with
    borrower_alice : Party
    borrower_bob : Party
    agent_charlie : Party
    agent_debbie : Party
    underwriter_emma : Party
    underwriter_fred : Party
    lender_gary : Party
    lender_hortense : Party
    fed_ingrid : Party
  deriving (Show, Eq, Ord)

initialTest : LedgerParties -> Script ()
initialTest parties = do
  stuff <- preOrigination parties
  loan <- origination parties stuff
  servicing parties loan

data PreOriginationStuff = PreOriginationStuff with
  aliceAccount : AccountKey

-- Pre-origination
preOrigination : LedgerParties -> Script PreOriginationStuff
preOrigination LedgerParties{..} = do
    -- Create the Fed

    -- Create USD
    let instrumentId = Id "USD"
        instrumentVersion = "0"
        usdInstrument = InstrumentKey with
          issuer = fed_ingrid
          depository = fed_ingrid
          id = instrumentId
          version = instrumentVersion

    -- Create USD Accounts for Banks and Companies
    accountFactoryCid <- toInterfaceContractId @Account.F <$> submit fed_ingrid do
      createCmd Account.Factory with provider = fed_ingrid; observers = empty

    holdingFactoryCid <- toInterfaceContractId @Holding.F <$> submit fed_ingrid do
      createCmd Fungible.Factory with
        provider = fed_ingrid
        observers = empty -- fromList [("PublicObserver", singleton public )] -- TODO: Probably wont need this

    -- ...for Hortenses's Bank
    hortenseRequestCid <- submit lender_hortense do
      createCmd CreateAccount.Request with owner = lender_hortense; custodian = fed_ingrid

    hortenseAccount <- submit fed_ingrid do
      exerciseCmd hortenseRequestCid CreateAccount.Accept with
        label = "Hortense@Bank"
        description = "Account of Hortense at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid = holdingFactoryCid
        observers = []

    -- allocate funds to Hortense
    hortenseRequestCid <- submit lender_hortense do
      createCmd CreditAccount.Request with
        account = hortenseAccount
        instrument = InstrumentKey with
          issuer = fed_ingrid
          depository = fed_ingrid
          id = instrumentId
          version = instrumentVersion
        amount = 100_000_000.00

    hortenseCashHoldingCid <- submit fed_ingrid do exerciseCmd hortenseRequestCid CreditAccount.Accept

    -- ...for Gary's Bank
    garyRequestCid <- submit lender_gary do
      createCmd CreateAccount.Request with owner = lender_gary; custodian = fed_ingrid
    garyAccount <- submit fed_ingrid do
      exerciseCmd garyRequestCid CreateAccount.Accept with
        label = "Gary@Bank"
        description = "Account of Bob at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid = holdingFactoryCid
        observers = []

    -- allocate funds to Gary
    garyRequestCid <- submit lender_gary do
      createCmd CreditAccount.Request with
        account = garyAccount
        instrument = InstrumentKey with
          issuer = fed_ingrid
          depository = fed_ingrid
          id = instrumentId
          version = instrumentVersion
        amount = 50_000_000.00

    garyCashHoldingCid <- submit fed_ingrid do exerciseCmd garyRequestCid CreditAccount.Accept

    -- ...for Bob's Company
    bobRequestCid <- submit borrower_bob do
      createCmd CreateAccount.Request with owner = borrower_bob; custodian = fed_ingrid
    bobAccount <- submit fed_ingrid do
      exerciseCmd bobRequestCid CreateAccount.Accept with
        label = "Bob@Fed"
        description = "Account of Bob at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid = holdingFactoryCid
        observers = []

    -- ...for Alice's Company
    aliceRequestCid <- submit borrower_alice do
      createCmd CreateAccount.Request with owner = borrower_alice; custodian = fed_ingrid
    aliceAccount <- submit fed_ingrid do
      exerciseCmd aliceRequestCid CreateAccount.Accept with
        label = "Alice@Bank"
        description = "Account of Alice at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid = holdingFactoryCid
        observers = []

    return $ PreOriginationStuff with
      aliceAccount

origination : LedgerParties -> PreOriginationStuff -> Script (ContractId PendingLoanAgreement)
origination LedgerParties{..} PreOriginationStuff{..} = do
  let amount = 10_000_000.00
      rate = RatePerAnnum 5.0 -- TODO: Huh
      durationInYears = 10
      loanApplication = LoanApplication with
        borrower = borrower_alice
        agent = agent_charlie
        duration = durationInYears
        amount
        maxInterestRate = rate
        prospectus = "To test the syndicated loans framework :)"
  application <- submit borrower_alice $ createCmd loanApplication
  underwritingRequest <- submit agent_charlie (makeUnderwritingRequest underwriter_emma loanApplication)
  underwritingResult <- makeUnderwritingResult underwriter_emma underwritingRequest
  let possibleLenders = [lender_gary, lender_hortense]
  forA_ possibleLenders $ \lender -> do
    makeFundingRequest agent_charlie amount underwritingResult lender
  fundingInterestCids <- forA possibleLenders $ \lender -> do
    [(fundingRequestCid, fundingRequest)] <- getFundingRequestsFor lender
    submit lender $ makeFundingInterest lender fundingRequestCid fundingRequest (amount, rate)
  fundingInterests <- forA fundingInterestCids $ \cid -> do
    Some fundingInterest <- queryContractId agent_charlie cid
    pure (cid, fundingInterest)
  (rate, selectedFundingInterests) <- selectFundingInterests fundingInterests
  loanProposal <- submit agent_charlie $ createLoanProposal agent_charlie borrower_alice amount rate
  acceptedLoan <- acceptLoanProposal borrower_alice loanProposal
  createPendingLoanAgreement agent_charlie acceptedLoan selectedFundingInterests

type Amount = Numeric 2

makeUnderwritingResult
    : Party
    -> ContractId UnderwritingRequest
    -> Script (ContractId UnderwritingResult)
makeUnderwritingResult underwriter requestCid = do
    Some request <- queryContractId underwriter requestCid
    submit underwriter $ createCmd UnderwritingResult with
        underwriter
        agent = request.loan.agent
        result = True
        uuid = "golden"

makeFundingRequest
    : Party
    -> Numeric 2
    -> ContractId UnderwritingResult
    -> Party
    -> Script (ContractId LoanRequest)
makeFundingRequest agent amount underwriteCid lender = do
    Some underwrite <- queryContractId agent underwriteCid
    disclosedUnderwriting <- submit agent $ exerciseCmd underwriteCid UnderwritingResult_Disclose with
        disclose_to = lender
    submit agent $ createCmd LoanRequest with
        agent
        uuid = "golden" -- TODO: Thread these through
        underwrite = disclosedUnderwriting
        participant = lender
        totalApplicationAmount = amount

getFundingRequestsFor : Party -> Script [(ContractId LoanRequest, LoanRequest)]
getFundingRequestsFor lender = query @LoanRequest lender

makeFundingInterest : Party -> ContractId LoanRequest -> LoanRequest -> (Amount, RatePerAnnum) -> Commands (ContractId LoanOffer)
makeFundingInterest lender _ loanRequest (amount, rate) = createCmd LoanOffer with
    agent = loanRequest.agent
    uuid = "golden" -- TODO: Thread these through
    participant = lender
    amount
    rate

makeUnderwritingRequest : Party -> LoanApplication -> Commands (ContractId UnderwritingRequest)
makeUnderwritingRequest underwriter loanApplication = createCmd UnderwritingRequest with
  underwriter
  uuid = "golden" -- TODO: Thread these through
  loan = loanApplication

selectFundingInterests : [(ContractId LoanOffer, LoanOffer)] -> Script (RatePerAnnum, [(ContractId LoanOffer, Amount)])
selectFundingInterests ((offerCid, offer)::interests) = pure (offer.rate, [(offerCid, offer.amount)])
selectFundingInterests [] = fail "No interests to fund loan"

createPendingLoanAgreement : Party -> ContractId AcceptedLoan -> [(ContractId LoanOffer, Amount)] -> Script (ContractId PendingLoanAgreement)
createPendingLoanAgreement agent acceptanceCid fundingCids = do
  Some acceptance <- queryContractId agent acceptanceCid
  lendersWithAmounts <- forA fundingCids $ \(offerCid, amount) -> do
    Some loanOffer <- queryContractId agent offerCid
    pure (loanOffer.participant, amount)
  let agreement = LoanAgreement with
        agent
        participantsWithAmount = Map.fromList lendersWithAmounts
        borrower = acceptance.borrower
        uuid = "golden" -- TODO: Thread these through
        prospectus = "uhhh" -- TODO: Get this
        loanTerms = LoanTerms with
          amount = acceptance.amount
          rate = acceptance.rate
          duration = 10 -- TODO: Get this

  submit agent $ createCmd PendingLoanAgreement with
    agreement
    signed = []

createLoanProposal : Party -> Party -> Amount -> RatePerAnnum -> Commands (ContractId SyndicatedLoanOffer)
createLoanProposal agent borrower amount rate = createCmd SyndicatedLoanOffer with
  agent
  borrower
  uuid = "golden" -- TODO: Thread these through
  amount
  rate

acceptLoanProposal : Party -> ContractId SyndicatedLoanOffer -> Script (ContractId AcceptedLoan)
acceptLoanProposal borrower offerCid = do
  Some offer <- queryContractId borrower offerCid
  submit borrower $ createCmd AcceptedLoan with
    agent = offer.agent
    borrower
    amount = offer.amount
    rate = offer.rate

-- TODO: This will take a LoanAgreement once we have multi-party signing implemented
-- servicing : LedgerParties -> ContractId PendingLoanAgreement -> Script ()
servicing LedgerParties{..} loan = do
  pure ()

settleLoan : LedgerParties -> LoanAgreement -> Script ()
settleLoan LedgerParties {..} loanAgreement = do
  -- 1. Create Route Provider
  routeProviderCid <- toInterfaceContractId @RouteProvider.I <$> submit fed_ingrid do
      createCmd SingleCustodian.SingleCustodian with
        provider = fed_ingrid
        observers = S.fromList [borrower_alice, borrower_bob]
        custodian = fed_ingrid

  -- 2. Create Settlement Factory
  settlementFactoryCid <- toInterfaceContractId @Settlement.F <$> submit fed_ingrid do
    createCmd Factory with
      provider = fed_ingrid
      observers = S.fromList [borrower_bob, borrower_alice]

  -- TODO: This is the part where you begin to construct
  -- 1: All lenders send funds to Agent
  -- 2: Agent sends funds to borrower

  settlementProposalCid <- submit agent_charlie do
    createCmd SettlementProposal with
      loan = loanAgreement
      sigAccumulator = []
      routeProviderCid
      settlementFactoryCid

  (batchCid, recSettleInstructionCid, paySettleInstructionCid) <- submit borrower_alice do
    exerciseCmd settlementProposalCid Borrower_Accept

  return ()


template SettlementProposal
  with
    loan : LoanAgreement
    sigAccumulator: [Party] -- Acquire acceptance from all parties
    routeProviderCid : ContractId RouteProvider.I
    settlementFactoryCid : ContractId Settlement.F
  where
    signatory loan.agent
    observer loan.borrower::(map fst $ Map.toList loan.participantsWithAmount)
    choice Accept_Borrower : Optional (ContractId Batch.I, ContractId Instruction.I, ContractId Instruction.I)
      controller loan.borrower
      do
        let lendersAndBorrowers = loan.borrower::(map fst $ Map.toList loan.participantsWithAmount)
        if sigAccumulator == lendersAndBorrowers then do
          -- TODO: DRY
          -- Settlement of lenders
          let lenderSteps = fmap loan.participantsWithAmount $ \(lender, investAmount) ->
                Step with sender = lender; receiver = loan.agent; quantity = investAmount
          -- Settlement of borrower
              borrowerStep =
                Step with sender = loan.agent; receiver = loan.borrower; quantity = loan.loanTerms.amount

          -- Discover settlement routes for the steps
          routedSteps <- exercise routeProviderCid RouteProvider.Discover with
            discoverors = fromList $ loan.agent::lendersAndBorrowers
            contextId = None
            steps = borrowerStep::lenderSteps

          -- Instruct settlement
          (containerCid, [recInstructionCid, payInstructionCid]) <-
            exercise settlementFactoryCid Settlement.Instruct with
              instructors = fromList $ loan.agent::lendersAndBorrowers
              settlers = singleton loan.agent
              id = Id id
              description = "Settlement for " <> id
              contextId = None
              routedSteps
              settlementTime = None -- i.e., immediate settlement

          return $ Some (containerCid, recInstructionCid, payInstructionCid)

        else do
          create this with sigAccumulator = loan.borrower::sigAccumulator
          return None
    choice Accept_Lender : Optional (ContractId Batch.I, ContractId Instruction.I, ContractId Instruction.I)
      controller (map fst $ Map.toList loan.participantsWithAmount)
      do
        if sigAccumulator == loan.borrower::(map fst $ Map.toList loan.participantsWithAmount) then do
          -- TODO: DRY
          -- Settlement of lenders
          let lenderSteps = fmap loan.participantsWithAmount $ \(lender, investAmount) ->
                Step with sender = lender; receiver = loan.agent; quantity = investAmount
          -- Settlement of borrower
              borrowerStep =
                Step with sender = loan.agent; receiver = loan.borrower; quantity = loan.loanTerms.amount

          -- Discover settlement routes for the steps
          routedSteps <- exercise routeProviderCid RouteProvider.Discover with
            discoverors = fromList $ loan.agent::lendersAndBorrowers
            contextId = None
            steps = borrowerStep::lenderSteps

          -- Instruct settlement
          (containerCid, [recInstructionCid, payInstructionCid]) <-
            exercise settlementFactoryCid Settlement.Instruct with
              instructors = fromList $ loan.agent::lendersAndBorrowers
              settlers = singleton loan.agent
              id = Id id
              description = "Settlement for " <> id
              contextId = None
              routedSteps
              settlementTime = None -- i.e., immediate settlement

          return $ Some (containerCid, recInstructionCid, payInstructionCid)

        -- add the current choice controller to the list of acquired signatures
        else do
          create this with sigAccumulator = choiceController::sigAccumulator
          return None

    choice Decline : ()
      -- ^ Decline the request.
      controller counterparty
      do pure ()

    choice Withdraw : ()
      -- ^ Withdraw the request.
      controller proposer
      do pure ()
