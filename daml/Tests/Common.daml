module Tests.Common
  ( LedgerParties(..)
  , PreOriginationStuff(..)
  , makeUnderwritingRequest
  , initialTest
  , preOrigination
  , Origination(..)
  , origination
  ) where

{-
  ALL Functions in the file should have a type signature of LedgerParties -> Script a, this is because
  DAML Hub cannot create parties via DAML Scripts. The local LSP can, but we want to be able to test
  against a live non-stateless ledger
-}

import DA.Action
import DA.Foldable
import DA.List as L
import DA.Map (Map)
import DA.Map qualified as Map
import DA.Set qualified as Set
import Daml.Script

import Daml.Finance.Account.Account qualified as Account (Factory(..))
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory (..))
import Daml.Finance.Interface.Account.Factory qualified as Account (F)
import Daml.Finance.Interface.Holding.Base qualified as B
import Daml.Finance.Interface.Holding.Factory qualified as Holding (F)
import Daml.Finance.Interface.Holding.Fungible (Fungible, SplitResult(..))
import Daml.Finance.Interface.Holding.Fungible qualified as Fungible
import Daml.Finance.Interface.Settlement.Factory qualified as Settlement
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction
import Daml.Finance.Interface.Settlement.RouteProvider qualified as RouteProvider
import Daml.Finance.Interface.Settlement.Types (Approval(..), Allocation(Pledge))
import Daml.Finance.Interface.Types.Common.Types
import Daml.Finance.Settlement.Factory (Factory(..))
import Daml.Finance.Settlement.RouteProvider.SingleCustodian qualified as SingleCustodian

import Util.Display
import Workflow.CreateAccount qualified as CreateAccount
import Workflow.CreditAccount qualified as CreditAccount
import Workflow.Origination
import Workflow.SettlementProposal
import Workflow.Transfer qualified as Transfer
import Workflow.Util

-- Helper Template for test batching
template Helper with
    p : Party
    fed : Party
  where
    signatory p
    observer fed, p
    choice BatchTransferRequests : [ContractId Transfer.Request]
      with cids : [ContractId Fungible]
           receiverAccounts : [AccountKey]
           instrument : InstrumentKey
           currentOwner : Party
           amount : Decimal
      controller p
      do
        let thing = zip receiverAccounts cids
        forA thing $ \(a, _b) -> do
          create Transfer.Request with
            receiverAccount = a
            instrument
            currentOwner
            amount

-- | Parties representing various agents in the syndicated loan workflow
-- Each type of agent has two representatives so that we can test disclosure
-- and divulgence.
data LedgerParties = LedgerParties with
    borrower_alice : Party
    borrower_bob : Party
    agent_charlie : Party
    agent_debbie : Party
    underwriter_emma : Party
    underwriter_fred : Party
    lender_gary : Party
    lender_hortense : Party
    fed_ingrid : Party
  deriving (Show, Eq, Ord)

-- | Test that does not exercise the lending workflow as such, but
-- exercises transfers on the ledger to help us estimate throughput
-- of our settlement strategy.
data Config = Config with
  instrument : InstrumentKey
  accountFactoryCid : ContractId Account.F
  holdingFactoryCid : ContractId Holding.F



perfTest : LedgerParties -> Script ()
perfTest LedgerParties{..} = do
    let instrumentId = Id "USD"
        instrumentVersion = "0"
        usdInstrument = InstrumentKey with
          issuer = fed_ingrid
          depository = fed_ingrid
          id = instrumentId
          version = instrumentVersion

    accountFactoryCid <- toInterfaceContractId @Account.F <$> submit fed_ingrid do
      createCmd Account.Factory with provider = fed_ingrid; observers = Map.empty

    holdingFactoryCid <- toInterfaceContractId @Holding.F <$> submit fed_ingrid do
      createCmd Fungible.Factory with
        provider = fed_ingrid
        observers = Map.fromList [("Alice", Set.fromList [borrower_alice])]

    let config = Config with
          instrument = usdInstrument
          accountFactoryCid
          holdingFactoryCid
    debug $ "Hortense"

    accounts_hortense <- createAccounts LedgerParties{..} (accountFactoryCid, holdingFactoryCid) 3000
    SplitResult{..} <- setupBorrower LedgerParties{..} config 1

    acchelper_hortense <- submit lender_hortense $
      createCmd Helper with
        p = lender_hortense
        fed = fed_ingrid

    debug $ "Batch Transfer Request"
    batch_transfer_request <- submit lender_hortense $ do
      exerciseCmd acchelper_hortense BatchTransferRequests with
        cids = splitCids
        receiverAccounts = accounts_hortense
        instrument = usdInstrument
        currentOwner = borrower_alice
        amount = 5.0

    let thing2 = zip batch_transfer_request splitCids
        thing3 = chunksOf 100 thing2

    debug $ "Length of [(ContractId Transfer.Request, ContractId Fungible)]: " <> show (L.length thing3)
    debug $ "Splitting Accept Events.."
    forA_ thing3 $ splitEvents LedgerParties{..}

    debug $ show splitCids
    debug $ show rest
    pure ()


-- Split up events into separate script batches to not crash the sequencer
splitEvents : LedgerParties -> [(ContractId Transfer.Request, ContractId Fungible)] -> Script ([ContractId B.I])
splitEvents LedgerParties{..} ids = do
  forA ids $ \(a, b) -> do
    debug $ "Batch Event running.. "
    submit borrower_alice $ exerciseCmd a Transfer.Accept with
      holdingCid = (coerceInterfaceContractId @B.Base b)


-- Create an N number of accounts for lender_hortense
createAccounts : LedgerParties -> (ContractId Account.F, ContractId Holding.F) -> Int -> Script [AccountKey]
createAccounts LedgerParties{..} (accountFactoryCid, holdingFactoryCid) amount = do
    forA [1..amount] $ \x -> do
      account <- submit lender_hortense $ createCmd CreateAccount.Request with owner = lender_hortense; custodian = fed_ingrid
      debug $ (show account)
      submit fed_ingrid $ do
          exerciseCmd account CreateAccount.Accept with
            label = (show x)
            description = "null"
            accountFactoryCid
            holdingFactoryCid
            observers = [borrower_alice]

-- Setup borrower alice
setupBorrower : LedgerParties -> Config -> Int -> Script (SplitResult)
setupBorrower LedgerParties{..} Config{..} amount = do
    aliceReq <- submit borrower_alice do
      createCmd CreateAccount.Request with owner = borrower_alice; custodian = fed_ingrid
    aliceAccount <- submit fed_ingrid do
      exerciseCmd aliceReq CreateAccount.Accept with
        label = "Alice@Fed"
        description = "null"
        accountFactoryCid
        holdingFactoryCid
        observers = [borrower_alice]
    requestMon <- submit borrower_alice do
        createCmd CreditAccount.Request with
          account = aliceAccount
          instrument = InstrumentKey with
            issuer = fed_ingrid
            depository = fed_ingrid
            id = instrument.id
            version = instrument.version
          amount = 100000.0
    xv <- submit fed_ingrid do exerciseCmd requestMon CreditAccount.Accept
    submit borrower_alice do
      exerciseCmd (coerceInterfaceContractId @Fungible xv) Fungible.Split with
        amounts = replicate amount 5.0

initialTest : LedgerParties -> Script ()
initialTest parties = do
  preOriginationStuff <- preOrigination parties
  origination : Origination <- origination parties preOriginationStuff
  _ <- settleLoan parties preOriginationStuff origination
  -- servicing parties originationData
  pure ()

-- | Information required for denominating the loans
-- and settling payments.
data PreOriginationStuff = PreOriginationStuff with
  accountFactoryCid : ContractId Account.F
  holdingFactoryCid : ContractId Holding.F
  usdInstrument : InstrumentKey
  ledgerAccounts : LedgerAccounts
  hortenseCashHoldingCid : ContractId B.I
  garyCashHoldingCid : ContractId B.I
  aliceCashHoldingCid : ContractId B.I

-- | Only a subset of the parties involved need to have accounts
-- to exercise the lifecycle of the loan.
-- In particular, the depository/issuer, and underwriters do not
-- need accounts.
data LedgerAccounts = LedgerAccounts with
    aliceAccount : AccountKey
    bobAccount : AccountKey
    charlieAccount : AccountKey
    debbieAccount : AccountKey
    garyAccount : AccountKey
    hortenseAccount : AccountKey
  deriving (Show, Eq, Ord)

-- Pre-origination set-up script that creates:
-- - the asset in which the loans will be denominated
-- - the issuer and depository for the asset (for simplicity, they are the same party)
-- - the accounts for the agents, lenders, and borrowers
-- - initial assets for the lenders
preOrigination : LedgerParties -> Script PreOriginationStuff
preOrigination LedgerParties{..} = do
    -- Create the Fed

    -- Create USD
    let instrumentId = Id "USD"
        instrumentVersion = "0"
        usdInstrument = InstrumentKey with
          issuer = fed_ingrid
          depository = fed_ingrid
          id = instrumentId
          version = instrumentVersion

    -- Create USD Accounts for Banks and Companies
    accountFactoryCid <- toInterfaceContractId @Account.F <$> submit fed_ingrid do
      createCmd Account.Factory
        with
          provider = fed_ingrid
          observers = Map.fromList $ (::[]) $ ("observers",) $ Set.fromList $
            [borrower_alice, borrower_bob]

    holdingFactoryCid <- toInterfaceContractId @Holding.F <$> submit fed_ingrid do
      createCmd Fungible.Factory with
        provider = fed_ingrid
        observers = Map.fromList $ (::[]) $ ("observers",) $ Set.fromList $
            [borrower_alice, borrower_bob]

    -- ...for Hortenses's Bank
    hortenseRequestCid <- submit lender_hortense do
      createCmd CreateAccount.Request with owner = lender_hortense; custodian = fed_ingrid

    hortenseAccount <- submit fed_ingrid do
      exerciseCmd hortenseRequestCid CreateAccount.Accept with
        label = "Hortense@Bank"
        description = "Account of Hortense at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid
        observers = []

    -- allocate funds to Hortense
    hortenseRequestCid <- submit lender_hortense do
      createCmd CreditAccount.Request with
        account = hortenseAccount
        instrument = usdInstrument
        amount = 100_000_000.00

    hortenseCashHoldingCid <- submit fed_ingrid do exerciseCmd hortenseRequestCid CreditAccount.Accept

    -- ...for Gary's Bank
    garyRequestCid <- submit lender_gary do
      createCmd CreateAccount.Request with owner = lender_gary; custodian = fed_ingrid
    garyAccount <- submit fed_ingrid do
      exerciseCmd garyRequestCid CreateAccount.Accept with
        label = "Gary@Bank"
        description = "Account of Bob at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid = holdingFactoryCid
        observers = []

    -- allocate funds to Gary
    garyRequestCid <- submit lender_gary do
      createCmd CreditAccount.Request with
        account = garyAccount
        instrument = usdInstrument
        amount = 70_000_000.00

    garyCashHoldingCid <- submit fed_ingrid do exerciseCmd garyRequestCid CreditAccount.Accept

    -- ...for Bob's Company
    bobRequestCid <- submit borrower_bob do
      createCmd CreateAccount.Request with owner = borrower_bob; custodian = fed_ingrid
    bobAccount <- submit fed_ingrid do
      exerciseCmd bobRequestCid CreateAccount.Accept with
        label = "Bob@Fed"
        description = "Account of Bob at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid = holdingFactoryCid
        observers = []

    -- ...for Alice's Company
    aliceRequestCid <- submit borrower_alice do
      createCmd CreateAccount.Request with owner = borrower_alice; custodian = fed_ingrid
    aliceAccount <- submit fed_ingrid do
      exerciseCmd aliceRequestCid CreateAccount.Accept with
        label = "Alice@Bank"
        description = "Account of Alice at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid = holdingFactoryCid
        observers = []
    aliceRequestCid <- submit borrower_alice do
      createCmd CreditAccount.Request with
        account = aliceAccount
        instrument = usdInstrument
        amount = 501_369.863

    aliceCashHoldingCid <- submit fed_ingrid do exerciseCmd aliceRequestCid CreditAccount.Accept

    -- ...for Charlie's agency
    charlieRequestCid <- submit agent_charlie do
      createCmd CreateAccount.Request with owner = agent_charlie; custodian = fed_ingrid
    charlieAccount <- submit fed_ingrid do
      exerciseCmd charlieRequestCid CreateAccount.Accept with
        label = "Charlie@Bank"
        description = "Account of Charlie at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid = holdingFactoryCid
        observers = []

    -- ...for Debbie's agency
    debbieRequestCid <- submit agent_debbie do
      createCmd CreateAccount.Request with owner = agent_debbie; custodian = fed_ingrid
    debbieAccount <- submit fed_ingrid do
      exerciseCmd debbieRequestCid CreateAccount.Accept with
        label = "Debbie@Bank"
        description = "Account of Debbie at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid = holdingFactoryCid
        observers = []

    let ledgerAccounts = LedgerAccounts with ..
    return $ PreOriginationStuff with
      accountFactoryCid
      holdingFactoryCid
      usdInstrument
      ledgerAccounts
      hortenseCashHoldingCid
      garyCashHoldingCid
      aliceCashHoldingCid

data Origination = Origination with
  loanAgreement : LoanAgreement
  loanAgreementCid : ContractId LoanAgreement
  bond : Bond
  aliceBondAccountKey : AccountKey
  garyBondAccountKey : AccountKey
  garyBondHoldingKey : ContractId B.I

origination : LedgerParties -> PreOriginationStuff -> Script Origination
origination LedgerParties{..} PreOriginationStuff{..} = do
  let amount = 10_000_000.00
      rate = RatePerAnnum 0.05 -- 5% per annum
      uuid = "LoanInstrument"
      loanApplicationSubmission = LoanApplicationSubmission with
        borrower = borrower_alice
        agent = agent_charlie
        applicationData = LoanApplicationData with
          instrument = usdInstrument
          amount
          maxInterestRate = rate
          prospectus = "To test the syndicated loans framework :)"
          durationYears = 10
  log loanApplicationSubmission
  -- Borrower submits an application for a loan
  application <- submit borrower_alice $ createCmd loanApplicationSubmission
  -- Agent accepts it
  acceptedApplication <- submit agent_charlie $ exerciseCmd application LoanApplicationSubmission_Accept
    with
      uuid
  -- Agent kicks off the loan application process
  applicationProcess <- submit agent_charlie $ exerciseCmd acceptedApplication AcceptedLoanApplication_StartProcess
  -- Agent coordinating the lending first asks an underwriter for a report
  underwritingRequest <- submit agent_charlie $ exerciseCmd applicationProcess LoanApplicationProcess_CreateUnderwritingRequest with
    underwriter = underwriter_emma
  underwritingResult <- makeUnderwritingResult underwriter_emma underwritingRequest
  -- Agent goes back to the borrower with a mandate letter offer
  mandateLetterOffer <- submit agent_charlie $ exerciseCmd underwritingResult UnderwritingResult_OfferMandateLetter
  acceptedMandateLetter <- submit borrower_alice $ exerciseCmd mandateLetterOffer MandateLetterOffer_Accept

  -- Agent with underwriter's report and accepted mandate letter in hand reaches out to possible lenders
  let possibleLenders = [lender_gary, lender_hortense]
  forA_ possibleLenders $ \lender -> do
    makeFundingRequest agent_charlie amount underwritingResult acceptedMandateLetter lender
  -- Lenders make their offers
  -- TODO: Lenders declining to make an offer
  fundingInterestCids <- forA possibleLenders $ \lender -> do
    [(fundingRequestCid, fundingRequest)] <- getFundingRequestsFor lender
    submit lender $ makeFundingInterest lender fundingRequestCid (amount / 2.0 + 1.0, rate)
  fundingInterests <- forA fundingInterestCids $ \cid -> do
    Some fundingInterest <- queryContractId agent_charlie cid
    pure (cid, fundingInterest)
  -- Agent takes all lending offers and constructs a loan offer for the borrower to consider
  let FundingSelection{..} = selectFundingInterests loanApplicationSubmission fundingInterests
  loanProposal <- submit agent_charlie $ createLoanProposal acceptedMandateLetter uuid fundingSelection_ratePerAnnum
  acceptedLoan <- acceptLoanProposal borrower_alice loanProposal
  -- Now that all parties have agreed to their individual terms, the agent constructs the final loan agreement
  -- and gathers the signatures that have been authorized.
  pendingAgreement <- createPendingLoanAgreement agent_charlie acceptedLoan fundingSelection_selected
  borrowerSigned <- submit agent_charlie $ do
    exerciseCmd acceptedLoan $ AcceptedLoan_SignAgreement with
      agreementCid = pendingAgreement
  lendersSigned <- foldlA
    (\agreementCid fundingInterestCid -> submit agent_charlie $ exerciseCmd fundingInterestCid FundingInterest_SignAgreement with agreementCid)
    borrowerSigned
    (Map.keys fundingSelection_selected)
  -- Agent declines leftover funding interests
  submit agent_charlie $ forA_ fundingSelection_declined $ \declinedCid -> exerciseCmd declinedCid FundingInterest_Decline
  -- Agent constructs the final, fully signed loan agreement— ready for settlement
  (loanAgreementCid, bond) <- submit agent_charlie $ exerciseCmd lendersSigned PendingLoanAgreement_Finalize
  Some loanAgreement <- queryContractId agent_charlie loanAgreementCid

  aliceAccountRequestCid <- submit borrower_alice do
    createCmd CreateAccount.Request with
      custodian = borrower_alice
      owner = borrower_alice

  aliceBondAccountKey <- submit borrower_alice do
    exerciseCmd aliceAccountRequestCid CreateAccount.Accept with
        label = "AliceBond@Bank"
        description = "Account for Alice's Bond at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid = holdingFactoryCid
        observers = []

  aliceBondRequestCid <- submit borrower_alice do
    createCmd CreditAccount.Request with
      account = ledgerAccounts.aliceAccount
      instrument = bond.reference
      amount = loanAgreement.loanTerms.amount

  aliceBondHoldingKey <- submit fed_ingrid do
    exerciseCmd aliceBondRequestCid CreditAccount.Accept

  garyAccountRequestCid <- submit lender_gary do
    createCmd CreateAccount.Request with
      custodian = borrower_alice
      owner = lender_gary

  garyBondAccountKey <- submit borrower_alice do
    exerciseCmd garyAccountRequestCid CreateAccount.Accept with
        label = "GaryBond@Bank"
        description = "Account for Gary's holding of Alice's Bond at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid = holdingFactoryCid
        observers = [borrower_alice]

  bondTransferReq <- submit lender_gary do
    createCmd Transfer.Request with
      receiverAccount = garyBondAccountKey
      instrument = bond.reference
      amount = loanAgreement.loanTerms.amount
      currentOwner = borrower_alice

  garyBondHoldingKey <- submit borrower_alice do
    exerciseCmd bondTransferReq Transfer.Accept with
      holdingCid = aliceBondHoldingKey

  pure Origination with
    loanAgreement
    loanAgreementCid
    bond
    aliceBondAccountKey
    garyBondAccountKey
    garyBondHoldingKey


type Amount = Decimal

makeUnderwritingResult
    : Party
    -> ContractId UnderwritingRequest
    -> Script (ContractId UnderwritingResult)
makeUnderwritingResult underwriter requestCid = do
    submit underwriter $ exerciseCmd requestCid CreateUnderwritingResult with
      result = True

makeFundingRequest
    : Party
    -> Decimal
    -> ContractId UnderwritingResult
    -> ContractId AcceptedMandateLetter
    -> Party
    -> Script (ContractId FundingRequest)
makeFundingRequest agent amount underwriteCid mandateLetterCid lender = do
    Some underwrite <- queryContractId agent underwriteCid
    disclosedUnderwriting <- submit agent $ exerciseCmd underwriteCid UnderwritingResult_Disclose with
        disclose_to = lender
        mandateLetterCid
    submit agent $ exerciseCmd disclosedUnderwriting MakeFundingRequest with
        requestee = lender

getFundingRequestsFor : Party -> Script [(ContractId FundingRequest, FundingRequest)]
getFundingRequestsFor lender = query @FundingRequest lender

-- TODO: Actually make a decision about amount and rate
makeFundingInterest : Party -> ContractId FundingRequest -> (Decimal, RatePerAnnum) -> Commands (ContractId FundingInterest)
makeFundingInterest lender requestCid (amount, rate) = exerciseCmd requestCid FundingRequest_Respond with
    amount = (amount - 1.0)
    rate

data FundingSelection = FundingSelection
  with
    fundingSelection_ratePerAnnum : RatePerAnnum
    fundingSelection_selected : Map (ContractId FundingInterest) Amount
    fundingSelection_declined : [ContractId FundingInterest]
  deriving (Eq, Ord, Show)

selectFundingInterests : LoanApplicationSubmission -> [(ContractId FundingInterest, FundingInterest)] -> FundingSelection
selectFundingInterests _ [] = error "No interests to fund loan"
selectFundingInterests application interests =
  let sortedInterests = flip L.sortBy interests $ \(_, fi_a) (_, fi_b) -> compare fi_a.rate fi_b.rate
      (bestRate, book, leftover) = buildBook application (RatePerAnnum 0.0) 0.0 Map.empty interests
   in FundingSelection with
        fundingSelection_ratePerAnnum = bestRate
        fundingSelection_selected = book
        fundingSelection_declined = leftover

-- | Given a *SORTED* list of funding interests, sorted from lowest to highest interest rate, gathers commitments
-- until either the loan amount is satisfied, or the loan cannot be constructed for want of funding at an acceptable
-- rate of interest.
buildBook
  : LoanApplicationSubmission
  -> RatePerAnnum
  -> Amount
  -> Map (ContractId FundingInterest) Amount
  -> [(ContractId FundingInterest, FundingInterest)]
  -> (RatePerAnnum, Map (ContractId FundingInterest) Amount, [ContractId FundingInterest])
buildBook application _ _ _ [] = error "Not enough funding interest to construct loan"
buildBook application currentInterest accumulatedAmount accumulatedBook ((fundingCid, funding)::fundings) =
  if funding.rate > application.applicationData.maxInterestRate
    then error "Not enough funding interest below the maximum interest rate to construct loan"
    else
      let remainingRequiredFunding = application.applicationData.amount - accumulatedAmount
       in if remainingRequiredFunding <= funding.amount
            then (funding.rate, Map.insertWith (+) fundingCid remainingRequiredFunding accumulatedBook, map fst fundings)
            else buildBook application funding.rate (accumulatedAmount + funding.amount) (Map.insertWith (+) fundingCid funding.amount accumulatedBook) fundings

createPendingLoanAgreement
  : Party
  -> ContractId AcceptedLoan
  -> Map (ContractId FundingInterest) Amount
  -> Script (ContractId PendingLoanAgreement)
createPendingLoanAgreement agent acceptanceCid lendersWithAmounts = do
  Some acceptance <- queryContractId agent acceptanceCid
  participantsWithAmounts <- fmap Map.fromList $ forA (Map.toList lendersWithAmounts) $ \(cid, amt) -> do
    Some funding <- queryContractId agent cid
    pure (funding.participant, amt)
  let agreement = LoanAgreement with
        agent
        participantsWithAmounts
        borrower = acceptance.borrower
        uuid = acceptance.uuid
        prospectus = acceptance.mandateLetter.prospectus
        loanTerms = acceptance.terms
  submit agent $ createCmd PendingLoanAgreement with
    agreement
    signed = []

createLoanProposal : ContractId AcceptedMandateLetter -> Text -> RatePerAnnum -> Commands (ContractId SyndicatedLoanOffer)
createLoanProposal applicationCid uuid rate = exerciseCmd applicationCid AcceptedMandateLetter_CreateOffer with
  uuid
  rate

acceptLoanProposal : Party -> ContractId SyndicatedLoanOffer -> Script (ContractId AcceptedLoan)
acceptLoanProposal borrower offerCid = do
  submit borrower $ exerciseCmd offerCid SyndicatedLoanOffer_Accept

servicing : LedgerParties -> Origination -> Script ()
servicing LedgerParties{..} origination = do

  pure ()

settleLoan : LedgerParties -> PreOriginationStuff -> Origination -> Script ()
settleLoan LedgerParties {..} preOriginationStuff origination = do
  -- Create Route Provider
  routeProviderCid <- toInterfaceContractId @RouteProvider.I <$> submit fed_ingrid do
      createCmd SingleCustodian.SingleCustodian with
        provider = fed_ingrid
        observers = Set.fromList [borrower_alice, borrower_bob, lender_gary, lender_hortense]
        custodian = fed_ingrid

  -- Create Settlement Factory
  settlementFactoryCid <- toInterfaceContractId @Settlement.F <$> submit fed_ingrid do
    createCmd Factory with
      provider = fed_ingrid
      observers = Set.fromList [borrower_bob, borrower_alice]

  -- Generate Settlement Proposal
  settlementProposalCid <- submit borrower_alice do
    createCmd SettlementProposal with
      loan = origination.loanAgreement
      sigAccumulator = []
      routeProviderCid
      settlementFactoryCid
      bond = origination.bond.reference

  -- Create a bond holding request
  aliceBondRequestCid <- submit borrower_alice do
    createCmd CreditAccount.Request with
      account = preOriginationStuff.ledgerAccounts.aliceAccount
      instrument = origination.bond.reference
      amount = origination.loanAgreement.loanTerms.amount

  -- Create a bond holding held by Alice
  aliceBondHoldingKey <- submit fed_ingrid do
    exerciseCmd aliceBondRequestCid CreditAccount.Accept

  -- Get sig of participating lender
  Left settlementProposalCid2 <- submit lender_hortense do
    exerciseCmd settlementProposalCid $ Accept_Lender lender_hortense

  -- Get sig of participating lender
  Left settlementProposalCid3 <- submit lender_gary do
    exerciseCmd settlementProposalCid2 $ Accept_Lender lender_gary

  -- Get sig of participating borrower, all signatures should have been accumulated, tx instructions should be produced
  -- TODO: Should case to ensure it actually is 'Some' instead of 'None'
  -- Right (batchCid, instructionCids) <- submit borrower_alice do
  --   exerciseCmd settlementProposalCid3 Accept_Borrower
  eitherUpdatedContractOrBatchInstructions <- submit borrower_alice do
    exerciseCmd settlementProposalCid3 Accept_Borrower

  (allSignatureSettlementCid, batchCid, instructionCids) <- case eitherUpdatedContractOrBatchInstructions of
    Left err -> fail $ "All signatures should be present " <> (show err)
    Right batchInstructions -> return batchInstructions

  -- Prepare to construct Allocate instructions
  -- let instructions : Update [Instruction.I] = mapA (\icid -> fetch icid) instructionCids
  instructionViews <- forA instructionCids $ \icid -> do
    iv <- submit borrower_alice $ exerciseCmd icid Instruction.GetView with viewer = borrower_alice
    pure (icid, iv)
  let routedSteps = map (\(icid, iv) -> (icid, iv.routedStep)) instructionViews

  -- Create bond holding for Alice
  -- aliceRequestCid <- submit borrower_alice do
  --   createCmd CreditAccount.Request with
  --     account = preOriginationStuff.ledgerAccounts.aliceAccount
  --     instrument = bond.reference
  --     amount =  loanAgreement.loanTerms.amount

  -- TODO: CAUTION DO NOT DO THIS, just a test
  -- aliceBondHoldingCid <- submit fed_ingrid do exerciseCmd aliceRequestCid CreditAccount.Accept

  -- initiate Map Party (ContractId Holding)
  let partyHoldingsMap = Map.fromList
        [ (lender_gary, Some preOriginationStuff.garyCashHoldingCid)
        , (lender_hortense, Some preOriginationStuff.hortenseCashHoldingCid)
        , (borrower_alice, Some aliceBondHoldingKey)
        ]

  let f (accum, map') (icid, routedStep) = do
        let key' = routedStep.sender
            optionalReceiverHoldingCid = Map.lookup key' map'
        debug $ "allocatedSettleInstructions: " <> show key'
        case optionalReceiverHoldingCid  of
          None -> fail $ "Could not find Holding for " <> show key'
          Some None -> fail $ "Insufficient funds for " <> show key'
          Some (Some receiverHoldingCid) -> do
            Fungible.SplitResult{splitCids, rest} <- submit key' do
              exerciseCmd (coerceInterfaceContractId @Fungible receiverHoldingCid) Fungible.Split with
                amounts = [routedStep.quantity.amount]
            debug $ "splitCids: " <> show splitCids
            debug $ "rest: " <> show rest
            assertMsg "we only split a single amount" $ Prelude.length splitCids == 1
            let Some splitCid = Some (L.head splitCids)
                newMap = Map.insert key' (coerceInterfaceContractId @B.Base <$> rest) map'

            allocInstructions <- submit key' do
              exerciseCmd icid Instruction.Allocate with
                actors = Set.singleton key'
                allocation = Pledge (coerceInterfaceContractId @B.Base splitCid)

            return ((routedStep.receiver, allocInstructions) :: accum, newMap)
  -- Have each party pledge where funds should be coming from
  allocatedSettleInstructions <- fst <$> foldlA f ([], partyHoldingsMap) routedSteps

  -- initiate Map Party AccountKey
  let partyAccountMap = Map.fromList
        [ (borrower_alice, preOriginationStuff.ledgerAccounts.aliceAccount)
        , (borrower_bob, preOriginationStuff.ledgerAccounts.bobAccount)
        , (lender_gary, preOriginationStuff.ledgerAccounts.garyAccount)
        , (lender_hortense, preOriginationStuff.ledgerAccounts.hortenseAccount)
        , (agent_charlie, preOriginationStuff.ledgerAccounts.charlieAccount)
        , (agent_debbie, preOriginationStuff.ledgerAccounts.debbieAccount)
        ]

  -- Have each party approve of transaction instructions
  approvedSettleInstuctionCids <- forA allocatedSettleInstructions $ \(approvingParty, (allocInstructionsCid, _)) -> submit approvingParty do
    let Some approvingPartyAccount = Map.lookup approvingParty partyAccountMap
    exerciseCmd allocInstructionsCid Instruction.Approve with
      actors = Set.singleton approvingParty
      approval = TakeDelivery approvingPartyAccount

  -- WARN: This can only be used in scripts, not on DAML Hub
  -- Settle batched transactions atomically
  -- holdingCids <- submitMulti [agent_charlie, borrower_alice, lender_gary, lender_hortense] [] do
  --     exerciseCmd batchCid Batch.Settle with
  --       actors = S.singleton agent_charlie

  -- Settle batched transactions atomically, now that all parties agree in SettlementProposal Contract
  settlementBases <- submit borrower_alice do
    exerciseCmd allSignatureSettlementCid $ ExecuteSettlement batchCid

  return ()

createRouteProvider : LedgerParties -> Script (ContractId RouteProvider.I)
createRouteProvider LedgerParties {..} = do
  -- 1. Create Route Provider
  toInterfaceContractId @RouteProvider.I <$> submit fed_ingrid do
      createCmd SingleCustodian.SingleCustodian with
        provider = fed_ingrid
        observers = Set.fromList [borrower_alice, borrower_bob]
        custodian = fed_ingrid
