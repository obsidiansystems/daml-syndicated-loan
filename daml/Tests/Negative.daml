module Tests.Negative where

import Daml.Script

import DA.Foldable
import DA.Set qualified as Set
import Workflow.Origination
import Scripts.Parties

import Tests.Common(PreOriginationStuff(..), FundingSelection(..), selectFundingInterests)

originationTests : LedgerParties -> PreOriginationStuff -> Script ()
originationTests ps@LedgerParties{..} PreOriginationStuff{..} = do
    let aliceApplicationData = LoanApplicationData with
          instrument = usdInstrument
          amount = 12_345_678.00
          maxInterestRate = RatePerAnnum 0.05 -- 5% per annum
          prospectus = "To validate the syndicated loans framework :)"
          durationYears = 10

        aliceLoanApplication = LoanApplicationSubmission with
            borrower = borrower_alice
            agent = agent_charlie
            applicationData = aliceApplicationData

{-
        bobApplicationData = LoanApplicationData with
          instrument = usdInstrument
          amount = 98_765_432.00
          maxInterestRate = RatePerAnnum 0.07 -- 7% per annum
          prospectus = "To break the syndicated loans framework >:)"
          durationYears = 7

        bobLoanApplication1 = LoanApplicationSubmission with
            borrower = borrower_bob
            agent = agent_debbie
            applicationData = bobApplicationData

        bobLoanApplication2 = LoanApplicationSubmission with
            borrower = borrower_bob
            agent = agent_debbie
            applicationData = bobApplicationData
-}

    -- Workflow for Alice to submit a loan
    -- Bob cannot submit an application for Alice
    submitMustFail borrower_bob $ createCmd aliceLoanApplication

    -- Alice submits her application
    aliceSubmittedApplicationCid <- submit borrower_alice $ createCmd aliceLoanApplication
    -- Only alice and her agent charlie should be able to see the application
    testVisibility ps [ borrower_alice, agent_charlie ] aliceSubmittedApplicationCid

    -- Charlie accepts the application, they are the only one who is able to do so
    -- They use a uuid to keep track of alice's application through the workflow
    let aliceApplicationUuid = "negative_alice"
    aliceApplicationCid <- testExercise ps agent_charlie aliceSubmittedApplicationCid LoanApplicationSubmission_Accept with
        uuid = aliceApplicationUuid

    -- It is the case that only alice and charlie can see the accepted application
    testVisibility ps [ borrower_alice, agent_charlie ] aliceApplicationCid

    -- To maintain the privacy of the underwriters and the lenders, Charlie kicks off a workflow not involving the borrower as a signatory
    -- Later on, we will ensure that the loan agreement corresponds with the application Alice submitted.
    aliceApplicationProcessCid <- testExercise ps agent_charlie aliceApplicationCid AcceptedLoanApplication_StartProcess
    testVisibility ps [ agent_charlie ] aliceApplicationProcessCid

    -- Charlie submits alice's application to an underwriterâ€” NO ONE else has
    -- the authority to do so.
    --
    -- NOTE: This emits a divulgence warning as Alice is a witness to the creation of the loan application process,
    -- but she cannot exercise the choice all the same. Moreover, she is not aware of any underwriting requests
    -- made through this exercise.
    aliceUnderwritingRequestCid <- testExercise ps agent_charlie aliceApplicationProcessCid LoanApplicationProcess_CreateUnderwritingRequest with
        underwriter = underwriter_emma
    -- The underwriter does not see the original application
    testVisibility ps [ borrower_alice, agent_charlie ] aliceApplicationCid
    -- Nor does alice see the underwriting request
    testVisibility ps [ agent_charlie, underwriter_emma ] aliceUnderwritingRequestCid

    -- The underwriter produces a result, in this case, they approve Alice's loan
    -- Note that they are the only one with the authority to exercise this choice.
    aliceUnderwritingCid <- testExercise ps underwriter_emma aliceUnderwritingRequestCid CreateUnderwritingResult with
      result = True
    -- The report is only visible to the underwriter and the agent who requested it
    testVisibility ps [ agent_charlie, underwriter_emma ] aliceUnderwritingCid

    -- With the report in hand, Charlie is prepared to make an offer to Alice.
    --
    -- NOTE: This emits a divulgence warning just as above. However, Alice can only see the application process contract,
    -- not anything underlying the underwriting process.
    aliceMandateLetterOfferCid <- testExercise ps agent_charlie aliceApplicationProcessCid LoanApplicationProcess_OfferMandateLetter with
        reportCid = aliceUnderwritingCid
    testVisibility ps [ borrower_alice, agent_charlie ] aliceMandateLetterOfferCid

    -- Alice accepts the offer
    aliceMandateLetterCid <- testExercise ps borrower_alice aliceMandateLetterOfferCid MandateLetterOffer_Accept
    testVisibility ps [ borrower_alice, agent_charlie ] aliceMandateLetterCid

    -- With the consent of the borrower in hand, Charlie can disclose the underwriting report to the lenders,
    -- and request funding based on the report.
    let prospectiveLenders = [ lender_gary, lender_hortense ]
    fundingRequests <- forA prospectiveLenders $ \lender -> do
        disclosedUnderwritingReportCid <- testExercise ps agent_charlie aliceUnderwritingCid UnderwritingResult_Disclose with
            disclose_to = lender
            mandateLetterCid = aliceMandateLetterCid
        -- only charlie and this specific lender can see this disclosure
        testVisibility ps [lender, agent_charlie] disclosedUnderwritingReportCid

        -- The disclosure allows charlie to make a funding request without the underwriter knowing who the prospective
        -- lender is.
        -- NOTE: Nevertheless, this emits divulgence warnings, as the underwriter is aware of the disclosure.
        -- We could rearrange the workflow so as to prevent the underwriter from seeing even that, if desired.
        fundingRequestCid <- testExercise ps agent_charlie disclosedUnderwritingReportCid MakeFundingRequest with
            requestee = lender
        -- only charlie and this specific lender can see this request
        testVisibility ps [lender, agent_charlie] fundingRequestCid

        pure (lender, fundingRequestCid)

    -- The lenders now consider their respective requests, and make commitments about how much they are willing to lend
    -- Here we will contrive some differing offers.
    fundingInterests <- forA fundingRequests $ \(lender, requestCid) -> do
        Some request <- queryContractId lender requestCid
        let RatePerAnnum maxRate = request.report.maxInterestRate
            (amount, rate)
                | lender == lender_gary = (request.totalApplicationAmount / 3.0 + 1.0, RatePerAnnum (maxRate - 0.005))
                | lender == lender_hortense = (request.totalApplicationAmount / 1.5 + 1.0, RatePerAnnum maxRate)
                | otherwise = (request.totalApplicationAmount, RatePerAnnum maxRate)
        cid <- testExercise ps lender requestCid FundingRequest_Respond with
            amount
            rate
        -- for convenience we will also pull the contents of the funding interest here
        Some c <- queryContractId agent_charlie cid
        pure (cid, c)

    -- Now that Charlie has some funding interest, they can construct a book and propose a loan to alice
    -- Note that this will likely be done OFF ledger.
    let FundingSelection{..} = selectFundingInterests aliceLoanApplication fundingInterests

    -- Charlie makes an offer to Alice that meets both Alice's requirements, and those of the lenders
    aliceLoanOfferCid <- testExercise ps agent_charlie aliceMandateLetterCid AcceptedMandateLetter_CreateOffer with
        rate = fundingSelection_ratePerAnnum
    -- At this point, only the agent and the borrower are aware of the loan offer
    testVisibility ps [borrower_alice, agent_charlie] aliceLoanOfferCid
    -- Even when Alice accepts the loan offer, it is not yet visible to other parties.
    aliceAcceptedLoanOfferCid <- testExercise ps borrower_alice aliceLoanOfferCid SyndicatedLoanOffer_Accept
    testVisibility ps [borrower_alice, agent_charlie] aliceAcceptedLoanOfferCid
    pure ()


-- Explicitly deconstruct the ledger parties so that if it changes, we notice to include them
partiesList : LedgerParties -> [Party]
partiesList = Set.toList . allParties

-- | Given a contract and a set of parties who should be able to view the contract,
-- confirms that this is the case and moreover, the other parties of the test script
-- cannot see the contract.
--
-- Note that this tests visibility by *querying*. Fetching could still succeed if
-- divulgence is in play. In order to test divulgence, we must attempt to exercise
-- a contract or fetch it within a transaction.
testVisibility
    : (HasTemplateTypeRep c, HasFromAnyTemplate c, HasToAnyTemplate c, HasAgreement c)
    => LedgerParties
    -> [Party] -- ^ Who should be able to see the contract?
    -> ContractId c
    -> Script ()
testVisibility ps shouldSee cid = do
    let shouldNotSee = filter (`Prelude.notElem` shouldSee) (partiesList ps)
    forA_ shouldSee $ \party -> do
        Some _ <- queryContractId party cid
        pure ()
    forA_ shouldNotSee $ \party -> do
        None <- queryContractId party cid
        pure ()

-- | Given a contract, a choice, and a party who should be able to exercise that choice on that contract,
-- confirms that no other user can exercise that choice and that user can.
testExercise
    : (HasExercise t c b, HasFromAnyTemplate t, HasToAnyTemplate t, HasTemplateTypeRep t, HasToAnyChoice t c b, HasFromAnyChoice t c b)
    => LedgerParties
    -> Party
    -> ContractId t
    -> c
    -> Script b
testExercise ps shouldExercise cid contract_choice = do
    let shouldNotExercise = filter (/= shouldExercise) (partiesList ps)
    forA_ shouldNotExercise $ \party -> do
        submitMustFail party $ exerciseCmd cid contract_choice
    submit shouldExercise $ exerciseCmd cid contract_choice
