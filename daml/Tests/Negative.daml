module Tests.Negative where

import Daml.Script

import DA.Foldable
import qualified DA.Map as Map
import qualified DA.Set as Set

import Daml.Finance.Account.Account qualified as Account (Factory(..))
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory (..))

import Daml.Finance.Interface.Types.Common.Types
import Daml.Finance.Interface.Account.Factory qualified as Account (F)
import Daml.Finance.Interface.Holding.Factory qualified as Holding (F)

import Workflow.CreateAccount qualified as CreateAccount
import Workflow.CreditAccount qualified as CreditAccount
import Workflow.Origination

import Tests.Common(LedgerParties(..), PreOriginationStuff(..))
import Tests.Common qualified as Common

preoriginationTests : LedgerParties -> Script ()
preoriginationTests LedgerParties{..} = do
    let usdInstrument = InstrumentKey with
            issuer = fed_ingrid
            depository = fed_ingrid
            id = Id "USD"
            version = "0"
        falseInstrument = InstrumentKey with
            issuer = borrower_bob
            depository = borrower_bob
            id = Id "USD"
            version = "0"

    accountFactoryCid <- toInterfaceContractId @Account.F <$> submit fed_ingrid do
        createCmd Account.Factory
          with
            provider = fed_ingrid
            observers = Map.fromList $ (::[]) $ ("observers",) $ Set.fromList $ 
                [borrower_alice, borrower_bob]

    holdingFactoryCid <- toInterfaceContractId @Holding.F <$> submit fed_ingrid do
        createCmd Fungible.Factory with
            provider = fed_ingrid
            observers = Map.fromList $ (::[]) $ ("observers",) $ Set.fromList $ 
                [borrower_alice, borrower_bob]

    -- Infuse the lenders with capital
    -- ...for Hortenses's Bank
    hortenseRequestCid <- submit lender_hortense do
      createCmd CreateAccount.Request with owner = lender_hortense; custodian = fed_ingrid

    hortenseAccount <- submit fed_ingrid do
      exerciseCmd hortenseRequestCid CreateAccount.Accept with
        label = "Hortense@Bank"
        description = "Account of Hortense at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid
        observers = []

    hortenseRequestCid <- submit lender_hortense do
      createCmd CreditAccount.Request with
        account = hortenseAccount
        instrument = usdInstrument
        amount = 100_000_000.00

    hortenseCashHoldingCid <- submit fed_ingrid do exerciseCmd hortenseRequestCid CreditAccount.Accept

    pure ()

originationTests : LedgerParties -> PreOriginationStuff -> Script ()
originationTests ps@LedgerParties{..} PreOriginationStuff{..} = do
    let aliceApplicationData = LoanApplicationData with
          instrument = usdInstrument
          amount = 12_345_678.00
          maxInterestRate = RatePerAnnum 0.05 -- 5% per annum
          prospectus = "To validate the syndicated loans framework :)"
          durationYears = 10
        
        aliceLoanApplication = LoanApplication with
            borrower = borrower_alice
            agent = agent_charlie
            applicationData = aliceApplicationData

        bobApplicationData = LoanApplicationData with
          instrument = usdInstrument
          amount = 98_765_432.00
          maxInterestRate = RatePerAnnum 0.07 -- 7% per annum
          prospectus = "To break the syndicated loans framework >:)"
          durationYears = 7
        
        bobLoanApplication1 = LoanApplication with
            borrower = borrower_bob
            agent = agent_debbie
            applicationData = bobApplicationData
        
        bobLoanApplication2 = LoanApplication with
            borrower = borrower_bob
            agent = agent_debbie
            applicationData = bobApplicationData

    -- Workflow for Alice to submit a loan
    -- Bob cannot submit an application for Alice
    submitMustFail borrower_bob $ createCmd aliceLoanApplication

    -- Alice submits her application
    aliceApplicationCid <- submit borrower_alice $ createCmd aliceLoanApplication
    -- Only alice and her agent charlie should be able to see the application
    testVisibility ps aliceApplicationCid [ borrower_alice, agent_charlie ]

    -- Charlie submits alice's application to an underwriter
    -- They use a uuid to keep track of alice's application through the workflow
    let aliceApplicationUuid = "negative_alice"
    aliceUnderwritingRequestCid <- submit agent_charlie $ Common.makeUnderwritingRequest
        underwriter_emma
        aliceApplicationUuid
        aliceApplicationCid

    -- The underwriter does not see the original application
    testVisibility ps aliceApplicationCid [ borrower_alice, agent_charlie ]
    -- Nor does alice see the underwriting request
    testVisibility ps aliceUnderwritingRequestCid [ agent_charlie, underwriter_emma ]

    aliceUnderwritingCid <- submit underwriter_emma $ exerciseCmd aliceUnderwritingRequestCid CreateUnderwritingResult with
      result = True
    -- Once the underwriting is complete, the original request has been archived
    testVisibility ps aliceUnderwritingRequestCid []
    -- The report is only visibile to the underwriter and the agent who requested it
    testVisibility ps aliceUnderwritingCid [ agent_charlie, underwriter_emma ]
    pure ()

-- | Given a contract and a set of parties who should be able to view the contract,
-- confirms that this is the case and moreover, the other parties of the test script
-- cannot see the contract.
testVisibility
    : (HasTemplateTypeRep c, HasFromAnyTemplate c, HasToAnyTemplate c, HasAgreement c)
    => LedgerParties
    -> ContractId c
    -> [Party] -- ^ Who should be able to see the contract?
    -> Script ()
testVisibility LedgerParties{..} cid shouldSee = do
    let partiesList =
            [ borrower_alice
            , borrower_bob
            , agent_charlie
            , agent_debbie
            , underwriter_emma
            , underwriter_fred
            , lender_gary
            , lender_hortense
            , fed_ingrid
            ]
        shouldNotSee = filter (`Prelude.notElem` shouldSee) partiesList
    forA_ shouldSee $ \party -> do
        Some _ <- queryContractId party cid
        pure ()
    forA_ shouldNotSee $ \party -> do
        None <- queryContractId party cid
        pure ()