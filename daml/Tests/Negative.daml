module Tests.Negative where

import Daml.Script

import DA.Foldable
import qualified DA.Map as Map
import qualified DA.Set as Set

import Daml.Finance.Account.Account qualified as Account (Factory(..))
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory (..))

import Daml.Finance.Interface.Types.Common.Types
import Daml.Finance.Interface.Account.Factory qualified as Account (F)
import Daml.Finance.Interface.Holding.Factory qualified as Holding (F)

import Workflow.CreateAccount qualified as CreateAccount
import Workflow.CreditAccount qualified as CreditAccount
import Workflow.Origination

import Tests.Common(LedgerParties(..), PreOriginationStuff(..))

preoriginationTests : LedgerParties -> Script ()
preoriginationTests LedgerParties{..} = do
    let usdInstrument = InstrumentKey with
            issuer = fed_ingrid
            depository = fed_ingrid
            id = Id "USD"
            version = "0"
        falseInstrument = InstrumentKey with
            issuer = borrower_bob
            depository = borrower_bob
            id = Id "USD"
            version = "0"

    accountFactoryCid <- toInterfaceContractId @Account.F <$> submit fed_ingrid do
        createCmd Account.Factory
          with
            provider = fed_ingrid
            observers = Map.fromList $ (::[]) $ ("observers",) $ Set.fromList $ 
                [borrower_alice, borrower_bob]

    holdingFactoryCid <- toInterfaceContractId @Holding.F <$> submit fed_ingrid do
        createCmd Fungible.Factory with
            provider = fed_ingrid
            observers = Map.fromList $ (::[]) $ ("observers",) $ Set.fromList $ 
                [borrower_alice, borrower_bob]

    -- Infuse the lenders with capital
    -- ...for Hortenses's Bank
    hortenseRequestCid <- submit lender_hortense do
      createCmd CreateAccount.Request with owner = lender_hortense; custodian = fed_ingrid

    hortenseAccount <- submit fed_ingrid do
      exerciseCmd hortenseRequestCid CreateAccount.Accept with
        label = "Hortense@Bank"
        description = "Account of Hortense at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid
        observers = []

    hortenseRequestCid <- submit lender_hortense do
      createCmd CreditAccount.Request with
        account = hortenseAccount
        instrument = usdInstrument
        amount = 100_000_000.00

    hortenseCashHoldingCid <- submit fed_ingrid do exerciseCmd hortenseRequestCid CreditAccount.Accept

    pure ()

originationTests : LedgerParties -> PreOriginationStuff -> Script ()
originationTests ps@LedgerParties{..} PreOriginationStuff{..} = do
    let aliceApplicationData = LoanApplicationData with
          instrument = usdInstrument
          amount = 12_345_678.00
          maxInterestRate = RatePerAnnum 0.05 -- 5% per annum
          prospectus = "To validate the syndicated loans framework :)"
          durationYears = 10
        
        aliceLoanApplication = LoanApplicationSubmission with
            borrower = borrower_alice
            agent = agent_charlie
            applicationData = aliceApplicationData

        bobApplicationData = LoanApplicationData with
          instrument = usdInstrument
          amount = 98_765_432.00
          maxInterestRate = RatePerAnnum 0.07 -- 7% per annum
          prospectus = "To break the syndicated loans framework >:)"
          durationYears = 7
        
        bobLoanApplication1 = LoanApplicationSubmission with
            borrower = borrower_bob
            agent = agent_debbie
            applicationData = bobApplicationData
        
        bobLoanApplication2 = LoanApplicationSubmission with
            borrower = borrower_bob
            agent = agent_debbie
            applicationData = bobApplicationData

    -- Workflow for Alice to submit a loan
    -- Bob cannot submit an application for Alice
    submitMustFail borrower_bob $ createCmd aliceLoanApplication

    -- Alice submits her application
    aliceApplicationCid <- submit borrower_alice $ createCmd aliceLoanApplication
    -- Only alice and her agent charlie should be able to see the application
    testVisibility ps [ borrower_alice, agent_charlie ] aliceApplicationCid

    -- Charlie submits alice's application to an underwriterâ€” NO ONE else has
    -- the authority to do so.
    -- They use a uuid to keep track of alice's application through the workflow
    let aliceApplicationUuid = "negative_alice"
    aliceUnderwritingRequestCid <- testExercise ps agent_charlie aliceApplicationCid LoanApplicationSubmission_CreateUnderwritingRequest with
        underwriter = underwriter_emma
        uuid = aliceApplicationUuid
    -- The underwriter does not see the original application
    testVisibility ps [ borrower_alice, agent_charlie ] aliceApplicationCid
    -- Nor does alice see the underwriting request
    testVisibility ps [ agent_charlie, underwriter_emma ] aliceUnderwritingRequestCid

    -- The underwriter produces a result, in this case, they approve Alice's loan
    -- Note that they are the only one with the authority to exercise this choice.
    aliceUnderwritingCid <- testExercise ps underwriter_emma aliceUnderwritingRequestCid CreateUnderwritingResult with
      result = True
    -- Once the underwriting is complete, the original request has been archived
    testVisibility ps [] aliceUnderwritingRequestCid
    -- The report is only visible to the underwriter and the agent who requested it
    testVisibility ps [ agent_charlie, underwriter_emma ] aliceUnderwritingCid


    pure ()


-- Explicitly deconstruct the ledger parties so that if it changes, we notice to include them
partiesList : LedgerParties -> [Party]
partiesList (LedgerParties a b c d e f g h i) =
    [ a, b, c, d, e, f, g, h, i ]

-- | Given a contract and a set of parties who should be able to view the contract,
-- confirms that this is the case and moreover, the other parties of the test script
-- cannot see the contract.
testVisibility
    : (HasTemplateTypeRep c, HasFromAnyTemplate c, HasToAnyTemplate c, HasAgreement c)
    => LedgerParties
    -> [Party] -- ^ Who should be able to see the contract?
    -> ContractId c
    -> Script ()
testVisibility ps shouldSee cid = do
    let shouldNotSee = filter (`Prelude.notElem` shouldSee) (partiesList ps)
    forA_ shouldSee $ \party -> do
        Some _ <- queryContractId party cid
        pure ()
    forA_ shouldNotSee $ \party -> do
        None <- queryContractId party cid
        pure ()

-- | Given a contract, a choice, and a party who should be able to exercise that choice on that contract,
-- confirms that no other user can exercise that choice and that user can.
testExercise
    : (HasExercise t c b, HasFromAnyTemplate t, HasToAnyTemplate t, HasTemplateTypeRep t, HasToAnyChoice t c b, HasFromAnyChoice t c b)
    => LedgerParties
    -> Party
    -> ContractId t
    -> c
    -> Script b
testExercise ps shouldExercise cid contract_choice = do
    let shouldNotExercise = filter (/= shouldExercise) (partiesList ps)
    forA_ shouldNotExercise $ \party -> do
        submitMustFail party $ exerciseCmd cid contract_choice
    submit shouldExercise $ exerciseCmd cid contract_choice