module Tests.Negative where

import Daml.Script

import DA.Foldable
import DA.Map qualified as Map
import DA.Set qualified as Set

import Daml.Finance.Account.Account qualified as Account (Factory(..))
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory (..))

import Daml.Finance.Interface.Types.Common.Types
import Daml.Finance.Interface.Account.Factory qualified as Account (F)
import Daml.Finance.Interface.Holding.Factory qualified as Holding (F)

import Workflow.CreateAccount qualified as CreateAccount
import Workflow.CreditAccount qualified as CreditAccount
import Workflow.Origination

import Tests.Common(LedgerParties(..), PreOriginationStuff(..))

preoriginationTests : LedgerParties -> Script ()
preoriginationTests LedgerParties{..} = do
    let usdInstrument = InstrumentKey with
            issuer = fed
            depository = fed
            id = Id "USD"
            version = "0"
        falseInstrument = InstrumentKey with
            issuer = borrower_bob
            depository = borrower_bob
            id = Id "USD"
            version = "0"

    accountFactoryCid <- toInterfaceContractId @Account.F <$> submit fed do
        createCmd Account.Factory
          with
            provider = fed
            observers = Map.fromList $ (::[]) $ ("observers",) $ Set.fromList $ 
                [borrower_alice, borrower_bob]

    holdingFactoryCid <- toInterfaceContractId @Holding.F <$> submit fed do
        createCmd Fungible.Factory with
            provider = fed
            observers = Map.fromList $ (::[]) $ ("observers",) $ Set.fromList $ 
                [borrower_alice, borrower_bob]

    -- Infuse the lenders with capital
    -- ...for Hortenses's Bank
    hortenseRequestCid <- submit lender_hortense do
      createCmd CreateAccount.Request with owner = lender_hortense; custodian = fed

    hortenseAccount <- submit fed do
      exerciseCmd hortenseRequestCid CreateAccount.Accept with
        label = "Hortense@Bank"
        description = "Account of Hortense at Bank"
        accountFactoryCid = accountFactoryCid
        holdingFactoryCid
        observers = []

    hortenseRequestCid <- submit lender_hortense do
      createCmd CreditAccount.Request with
        account = hortenseAccount
        instrument = usdInstrument
        amount = 100_000_000.00

    hortenseCashHoldingCid <- submit fed do exerciseCmd hortenseRequestCid CreditAccount.Accept

    pure ()

originationTests : LedgerParties -> PreOriginationStuff -> Script ()
originationTests ps@LedgerParties{..} PreOriginationStuff{..} = do
    let aliceApplicationData = LoanApplicationData with
          instrument = usdInstrument
          amount = 12_345_678.00
          maxInterestRate = RatePerAnnum 0.05 -- 5% per annum
          prospectus = "To validate the syndicated loans framework :)"
          durationYears = 10
        
        aliceLoanApplication = LoanApplicationSubmission with
            borrower = borrower_alice
            agent = agent_charlie
            applicationData = aliceApplicationData

        bobApplicationData = LoanApplicationData with
          instrument = usdInstrument
          amount = 98_765_432.00
          maxInterestRate = RatePerAnnum 0.07 -- 7% per annum
          prospectus = "To break the syndicated loans framework >:)"
          durationYears = 7
        
        bobLoanApplication1 = LoanApplicationSubmission with
            borrower = borrower_bob
            agent = agent_debbie
            applicationData = bobApplicationData
        
        bobLoanApplication2 = LoanApplicationSubmission with
            borrower = borrower_bob
            agent = agent_debbie
            applicationData = bobApplicationData

    -- Workflow for Alice to submit a loan
    -- Bob cannot submit an application for Alice
    submitMustFail borrower_bob $ createCmd aliceLoanApplication

    -- Alice submits her application
    aliceSubmittedApplicationCid <- submit borrower_alice $ createCmd aliceLoanApplication
    -- Only alice and her agent charlie should be able to see the application
    testVisibility ps [ borrower_alice, agent_charlie ] aliceSubmittedApplicationCid

    -- Charlie accepts the application, they are the only one who is able to do so
    -- They use a uuid to keep track of alice's application through the workflow
    let aliceApplicationUuid = "negative_alice"
    aliceApplicationCid <- testExercise ps agent_charlie aliceSubmittedApplicationCid LoanApplicationSubmission_Accept with
        uuid = aliceApplicationUuid

    -- It is the case that only alice and charlie can see the accepted application
    testVisibility ps [ borrower_alice, agent_charlie ] aliceApplicationCid

    -- To maintain the privacy of the underwriters and the lenders, Charlie kicks off a workflow not involving the borrower as a signatory
    -- Later on, we will ensure that the loan agreement corresponds with the application Alice submitted.
    aliceApplicationProcessCid <- testExercise ps agent_charlie aliceApplicationCid AcceptedLoanApplication_StartProcess
    testVisibility ps [ agent_charlie ] aliceApplicationProcessCid

    -- Charlie submits alice's application to an underwriterâ€” NO ONE else has
    -- the authority to do so.
    --
    -- NOTE: This emits a divulgence warning as Alice is a witness to the creation of the loan application process,
    -- but she cannot exercise the choice all the same. Moreover, she is not aware of any underwriting requests
    -- made through this exercise.
    aliceUnderwritingRequestCid <- testExercise ps agent_charlie aliceApplicationProcessCid LoanApplicationProcess_CreateUnderwritingRequest with
        underwriter = underwriter_emma
    -- The underwriter does not see the original application
    testVisibility ps [ borrower_alice, agent_charlie ] aliceApplicationCid
    -- Nor does alice see the underwriting request
    testVisibility ps [ agent_charlie, underwriter_emma ] aliceUnderwritingRequestCid

    -- The underwriter produces a result, in this case, they approve Alice's loan
    -- Note that they are the only one with the authority to exercise this choice.
    aliceUnderwritingCid <- testExercise ps underwriter_emma aliceUnderwritingRequestCid CreateUnderwritingResult with
      result = True
    -- Once the underwriting is complete, the original request has been archived
    testVisibility ps [] aliceUnderwritingRequestCid
    -- The report is only visible to the underwriter and the agent who requested it
    testVisibility ps [ agent_charlie, underwriter_emma ] aliceUnderwritingCid

    -- With the report in hand, Charlie is prepared to make an offer to Alice.
    --
    -- NOTE: This emits a divulgence warning just as above. However, Alice can only seen the application process contract,
    -- not anything underlying the underwriting process.
    aliceMandateLetterOfferCid <- testExercise ps agent_charlie aliceApplicationProcessCid LoanApplicationProcess_OfferMandateLetter with
        reportCid = aliceUnderwritingCid

    pure ()


-- Explicitly deconstruct the ledger parties so that if it changes, we notice to include them
partiesList : LedgerParties -> [Party]
partiesList (LedgerParties a b c d e f g h i) =
    [ a, b, c, d, e, f, g, h, i ]

-- | Given a contract and a set of parties who should be able to view the contract,
-- confirms that this is the case and moreover, the other parties of the test script
-- cannot see the contract.
--
-- Note that this tests visibility by *querying*. Fetching could still succeed if
-- divulgence is in play. In order to test divulgence, we must attempt to exercise
-- a contract or fetch it within a transaction.
testVisibility
    : (HasTemplateTypeRep c, HasFromAnyTemplate c, HasToAnyTemplate c, HasAgreement c)
    => LedgerParties
    -> [Party] -- ^ Who should be able to see the contract?
    -> ContractId c
    -> Script ()
testVisibility ps shouldSee cid = do
    let shouldNotSee = filter (`Prelude.notElem` shouldSee) (partiesList ps)
    forA_ shouldSee $ \party -> do
        Some _ <- queryContractId party cid
        pure ()
    forA_ shouldNotSee $ \party -> do
        None <- queryContractId party cid
        pure ()

-- | Given a contract, a choice, and a party who should be able to exercise that choice on that contract,
-- confirms that no other user can exercise that choice and that user can.
testExercise
    : (HasExercise t c b, HasFromAnyTemplate t, HasToAnyTemplate t, HasTemplateTypeRep t, HasToAnyChoice t c b, HasFromAnyChoice t c b)
    => LedgerParties
    -> Party
    -> ContractId t
    -> c
    -> Script b
testExercise ps shouldExercise cid contract_choice = do
    let shouldNotExercise = filter (/= shouldExercise) (partiesList ps)
    forA_ shouldNotExercise $ \party -> do
        submitMustFail party $ exerciseCmd cid contract_choice
    submit shouldExercise $ exerciseCmd cid contract_choice