module Workflow.Origination where

import Workflow.Servicing
import Workflow.Util

import DA.Date (date, toGregorian, addDays, toDateUTC)
import DA.Map (Map)
import qualified DA.Map as Map
import qualified DA.Set as Set

import Daml.Finance.Instrument.Bond.FixedRate.Instrument (Instrument(..))
import Daml.Finance.Interface.Types.Common.Types (InstrumentKey(..), Id(Id))
import Daml.Finance.Interface.Types.Date.Calendar (BusinessDayAdjustment(..), BusinessDayConventionEnum(..))
import Daml.Finance.Interface.Types.Date.DayCount (DayCountConventionEnum(..))
import Daml.Finance.Interface.Types.Date.RollConvention (PeriodEnum(Y), RollConventionEnum(..), Period(..))
import Daml.Finance.Interface.Types.Date.Schedule (Frequency(..), ScheduleFrequency(..), PeriodicSchedule(..))
import qualified Daml.Finance.Interface.Instrument.Base.Instrument as BaseInstrument
import qualified Daml.Finance.Interface.Types.Date.Calendar as Cal
import qualified Daml.Finance.Interface.Types.Date.Schedule as Sched
import qualified Daml.Finance.Interface.Lifecycle.Rule.Lifecycle as Lifecycle
import qualified Daml.Finance.Claims.Lifecycle.Rule as LifecycleRule
import qualified Daml.Finance.Interface.Lifecycle.Rule.Claim as ClaimI
import qualified Daml.Finance.Lifecycle.Rule.Claim as Claim
import qualified Daml.Finance.Interface.Settlement.RouteProvider as RouteProvider
import Daml.Finance.Settlement.RouteProvider.IntermediatedStatic (IntermediatedStatic(..))
import Daml.Finance.Settlement.Hierarchy (Hierarchy(..))
import qualified Daml.Finance.Interface.Settlement.Factory as Settlement
import Daml.Finance.Settlement.Factory (Factory(..))


-- ### TODO
--   * Include "start date" of the loan (used to calculate coupon payment dates)
--      * Equal to the day at which the loan principal amount is transferred to the borrower.
--   * Figure out what to use as the output of this step to be used as input to the servicing process.
--   * Use daml-finance types for specifying e.g. coupon payment schedule (cf. https://docs.daml.com/daml-finance/reference/code-documentation/daml-finance-rst/Daml-Finance-Instrument-Bond-FixedRate-Instrument.html)
--      * Maybe just include the payment schedule in the final output of this whole process (to be used as input for the servicing process)

-- | Rate per annum.
-- E.g. "3.5% per annum" is represented as 0.035
newtype RatePerAnnum = RatePerAnnum { unRatePerAnnum : Decimal }
  deriving (Eq, Show, Ord)

data LoanApplicationData = LoanApplicationData
  with
    instrument : InstrumentKey
    -- ^ The instrument in which the loan is denominated
    amount : Decimal
    -- ^ The amount requested
    durationYears : Int
    -- ^ The loan term requested
    maxInterestRate : RatePerAnnum
    -- ^ The maximum interest rate desired
    prospectus : Text
    -- ^ An explanation, by the borrower, of what the loan will be used for
  deriving (Eq, Ord, Show)

-- | An application for a loan by a borrower
-- NOTE: Borrowers may create and freely submit loan applications to agents. We do
-- not limit the ability to apply in any way.
template LoanApplication
  with
    borrower : Party
    agent : Party
    applicationData : LoanApplicationData
  where
    signatory borrower
    observer agent

    nonconsuming choice LoanApplication_CreateUnderwritingRequest : ContractId UnderwritingRequest
      with
        underwriter : Party
        uuid : Text
      controller agent

      do
        create UnderwritingRequest with
          underwriter
          uuid
          loan = this

    choice LoanApplication_CreateOffer : ContractId SyndicatedLoanOffer
      with
        rate : RatePerAnnum
        uuid : Text
      controller agent
      do
        create SyndicatedLoanOffer with
          borrower
          agent
          uuid
          applicationData
          terms = LoanTerms with
            instrument = applicationData.instrument
            amount = applicationData.amount
            rate
            durationYears = applicationData.durationYears

template UnderwritingRequest
  with
    underwriter : Party
    uuid : Text -- Generated client-side by the agent so that each 'LoanApplication' has unique ID. We could also use a 'ContractId LoanApplication' to be the unique ID for a 'UnderwritingRequest', but the borrower has the ability to archive the LoanApplication, and we don't want to give the borrower the ability to delete a piece of data that is referred to by contracts involving other parties.
    loan : LoanApplication -- See comment above
  where
    signatory loan.agent
    observer underwriter
    key (loan.agent, uuid) : (Party, Text)
    maintainer key._1

    choice CreateUnderwritingResult : ContractId UnderwritingResult
      with
        result : Bool
      controller underwriter
      do
        create UnderwritingResult with
          underwriter
          agent = loan.agent
          applicationData = loan.applicationData
          uuid
          result

template UnderwritingResult
  with
    underwriter : Party
    uuid : Text
    agent : Party
    applicationData : LoanApplicationData
    result : Bool
  where
    signatory agent, underwriter
    key (underwriter, agent, uuid) : (Party, Party, Text)
    maintainer key._1

    nonconsuming choice UnderwritingResult_Disclose : ContractId UnderwritingDisclosure
      with
        disclose_to : Party
      controller agent
      do
        create UnderwritingDisclosure with
          underwriting = this
          participant = disclose_to

template UnderwritingDisclosure
  with
    underwriting : UnderwritingResult
    participant : Party
  where
    signatory underwriting.underwriter, underwriting.agent
    observer participant

    nonconsuming choice MakeFundingRequest : ContractId FundingRequest
      with
        participant : Party
      controller underwriting.agent
      do
        create FundingRequest with
          agent = underwriting.agent
          uuid = underwriting.uuid
          totalApplicationAmount = underwriting.applicationData.amount
          participant
          underwrite = self

-- | A request created by the agent inviting a single participant to make an offer on a 'LoanApplication'
template FundingRequest
  with
    agent : Party
    uuid : Text
    underwrite : ContractId UnderwritingDisclosure
    totalApplicationAmount : Decimal
    -- ^ Invariant: must be equal to the LoanApplication.amount that is pointed to by this contract's key
    participant : Party
    -- ^ The agent creates one 'FundingRequest' for each participant from whom it wants an offer
  where
    signatory agent
    observer participant
    key (agent, participant, uuid) : (Party, Party, Text)
    maintainer key._1

    choice FundingRequest_Respond : ContractId FundingInterest
      with
        amount : Decimal
        rate : RatePerAnnum
      controller participant
      do
        disclosed <- fetch underwrite
        assertMsg "Must respond with an interest rate less than the maximum underwritten" $
          rate <= disclosed.underwriting.applicationData.maxInterestRate
        create FundingInterest with
          agent
          uuid
          participant
          instrument = disclosed.underwriting.applicationData.instrument
          amount
          rate

-- | An offer by a participant to loan part (or all of) of the amount specified by the LoanApplication
template FundingInterest
  with
    agent : Party
    uuid : Text
    participant : Party
    instrument : InstrumentKey
    amount : Decimal
    rate : RatePerAnnum
    -- TODO: for now we just reject offers that are greater than LoanApplication.maxInterestRate, but eventually we'd like to accept all offers that makes it possible for the agent to offer a final loan of less than or equal to LoanApplication.maxInterestRate.
  where
    signatory participant
    observer agent
    key (participant, agent, uuid) : (Party, Party, Text)
    maintainer key._1
    choice FundingInterest_Decline : ()
      controller agent
      do
        pure ()
    choice FundingInterest_SignAgreement : ContractId PendingLoanAgreement
      with
        agreementCid : ContractId PendingLoanAgreement
      controller agent
      do
        pendingAgreement <- fetch agreementCid
        let agreement = pendingAgreement.agreement
        case Map.lookup this.participant agreement.participantsWithAmounts of
          None -> fail "Loan terms do not include this lender"
          Some myAmount -> do
            assertMsg "Interest offered does not exceed agreed upon rate" $
              rate >= this.rate
            assertMsg "Amount required exceeds agreed upon amount" $
              this.amount >= myAmount
            exercise agreementCid PendingLoanAgreement_Sign with
              signer = this.participant

template SyndicatedLoanOffer
  with
    agent : Party
    uuid : Text
    borrower : Party
    applicationData : LoanApplicationData
    terms : LoanTerms
    --NOTE: Maybe a covenant, once agreed by the borrower, could actually grant access to some on-chain data in the future, which is necessary to enforce it. and this could also trigger on-chain modifications of the loan.
  where
    signatory agent
    observer borrower
    key (agent, uuid) : (Party, Text)
    maintainer key._1
    choice SyndicatedLoanOffer_Accept : ContractId AcceptedLoan
      controller borrower
      do
        create AcceptedLoan with
          agent
          borrower
          uuid
          applicationData
          terms

data LoanTerms = LoanTerms with
    instrument : InstrumentKey
    amount : Decimal -- Principal. TODO: for now always equal to LoanApplication.amount
    rate : RatePerAnnum
    -- ^ The interest amount paid by the borrower yearly is (amount * rate).
    -- ^ TODO: for now this is always equal to LoanApplication.maxInterestRate, but we want this to become an amount-weighted average of offered participant rates
    durationYears : Int
    -- ^ Number of times the borrower pays interest, as well as the number of years after which the principal amount must be returned to the lenders.
      deriving (Eq, Show)

template AcceptedLoan
  with
    agent : Party
    borrower : Party
    uuid : Text
    applicationData : LoanApplicationData
    terms : LoanTerms
  where
    signatory borrower
    observer agent
    choice AcceptedLoan_SignAgreement : ContractId PendingLoanAgreement
      with
        agreementCid : ContractId PendingLoanAgreement
      controller agent
      do
        agreement <- fetch agreementCid
        let pendingTerms = agreement.agreement.loanTerms
        assertMsg "Accepted terms do not agree with final loan agreement" $
          this.terms == pendingTerms
        exercise agreementCid PendingLoanAgreement_Sign with
          signer = this.borrower

-- The final loan agreement should include all parties. The privacy barrier is dropped in this final step. In the bookbuilding process, no identities are revealed.
template LoanAgreement
  with
    agent : Party
    participantsWithAmounts : Map Party (Decimal)
    borrower : Party
    uuid : Text -- Points to UnderwritingRequest.uuid
    prospectus : Text
    loanTerms : LoanTerms
  where
    signatory agent, borrower, Map.keys participantsWithAmounts
    ensure sum (Map.values participantsWithAmounts) == loanTerms.amount

template PendingLoanAgreement
  with
    agreement : LoanAgreement
    signed : [Party]
  where
    -- TODO: ensure clause
    signatory agreement.agent, signed
    observer (Map.keys agreement.participantsWithAmounts), agreement.borrower
    choice PendingLoanAgreement_Sign : ContractId PendingLoanAgreement
      with
        signer : Party
      controller signer
      do
        create this with
          signed = signer :: (this.signed)
    choice PendingLoanAgreement_Finalize : ContractId OriginatedLoanAgreement
      with
        now : Time
        routeProviderCid : ContractId RouteProvider.I
        settlementFactoryCid : ContractId Settlement.F   
      controller agreement.agent
      do
        let bondInstrument = loanAgreementToBond now this.agreement.loanTerms.instrument this.agreement
        bondCid <- create bondInstrument
        let bondCid' = toInterfaceContractId @BaseInstrument.I bondCid
        bondKey <- createReference
          bondCid'
          bondInstrument.depository
          bondInstrument.issuer
          bondInstrument.observers

        create OriginatedLoanAgreement with
          agreement = this.agreement
          bondInstrument
          bondKey
          bondCid
          routeProviderCid
          settlementFactoryCid

template OriginatedLoanAgreement
  with
    agreement : LoanAgreement
    bondInstrument : BondInstrument
    bondKey : InstrumentKey
    bondCid : ContractId BondInstrument
    routeProviderCid : ContractId RouteProvider.I
    settlementFactoryCid : ContractId Settlement.F
  where
    signatory agreement.agent, agreement.borrower, Map.keys agreement.participantsWithAmounts
    ensure sum (Map.values agreement.participantsWithAmounts) == agreement.loanTerms.amount

    nonconsuming choice EnactLifecycling : ()
      with today : Date
      controller agreement.agent
      do
        let agent = agreement.agent
            borrower = agreement.borrower
            lenders = Map.keys agreement.participantsWithAmounts
            lenderSet = Set.fromList lenders
        
        let parties = Set.fromList (signatory this)
            updateEvent = clockUpdateEvent parties parties today
        updateEventCid <- toInterfaceContractId <$> create updateEvent
        lifecycleRule <- fmap (toInterfaceContractId @Lifecycle.Lifecycle) $
          create $ LifecycleRule.Rule with
            providers = Set.fromList [borrower]
            observers = Map.empty
            lifecycler = agent
            id = Id "LifecycleRule"
            description = "Rule to lifecycle the bond instrument"
        claimRule <- fmap (toInterfaceContractId @ClaimI.I) $
          create $ Claim.Rule with
            providers = Set.fromList [borrower]
            claimers = lenderSet
            settlers = Set.union (Set.fromList [borrower, agent]) lenderSet
            routeProviderCid
            settlementFactoryCid
            netInstructions = False
        (newBondOpt, [effectCid]) <-
          exercise lifecycleRule Lifecycle.Evolve with
            eventCid = updateEventCid
            instrument = bondKey
            observableCids = []

        return ()

-- Need to provide some proof to P that A gave the loan amount to the same B that was underwritten. Can we do this without revealing B's identity?

-- NOTE: pays to agent for now. TODO: pay to participants
loanAgreementToBond
  :  Time -- Current time
  -> InstrumentKey -- USD
  -> LoanAgreement
  -> BondInstrument
loanAgreementToBond now usd a =
  let numberOfParticipants = Map.size a.participantsWithAmounts
  in Instrument with
    depository = a.borrower -- a.agent -- TODO: A bit odd
    issuer = a.borrower
    id = Id a.uuid
    version = "0"
    description = "Fixed-rate bond"
    couponRate = unRatePerAnnum a.loanTerms.rate
    periodicSchedule = schedule
    holidayCalendarIds = [] -- NOT USED!
    calendarDataProvider = a.agent -- NOT USED!
    dayCountConvention = Act365Fixed -- TODO: how does this impact servicing rules?
    currency = usd
    observers = Map.fromList $ zip (map show [1..numberOfParticipants]) (map Set.singleton (Map.keys a.participantsWithAmounts))
    lastEventTimestamp = now
  where
    startDate = toDateUTC now

    (y,m,d) = toGregorian startDate

    schedule = createPaymentPeriodicSchedule
      (date (y+1) m d)
      []
      Following
      Y
      1
      startDate
      (date (y+5) m d)

-- | Create a schedule for periodic payments.
createPaymentPeriodicSchedule : Date -> [Text] -> Cal.BusinessDayConventionEnum -> PeriodEnum ->
  Int -> Date -> Date -> PeriodicSchedule
createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod
  couponPeriodMultiplier issueDate maturityDate = do
    -- CREATE_PERIODIC_SCHEDULE_BEGIN
    let
      (y, m, d) = toGregorian firstCouponDate
      periodicSchedule = PeriodicSchedule with
        businessDayAdjustment =
          Cal.BusinessDayAdjustment with
            calendarIds = holidayCalendarIds
            convention = businessDayConvention
        effectiveDateBusinessDayAdjustment = None
        terminationDateBusinessDayAdjustment = None
        frequency =
          Sched.Periodic Sched.Frequency with
            rollConvention = DOM d
            period = Period with
              period = couponPeriod
              periodMultiplier = couponPeriodMultiplier
        effectiveDate = issueDate
        firstRegularPeriodStartDate = Some firstCouponDate
        lastRegularPeriodEndDate = Some maturityDate
        stubPeriodType = None
        terminationDate = maturityDate
    -- CREATE_PERIODIC_SCHEDULE_END
    periodicSchedule
