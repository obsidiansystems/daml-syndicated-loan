module Workflow.Origination where

import Daml.Finance.Interface.Types.Date.Schedule (PeriodicSchedule(..))
import Daml.Finance.Instrument.Bond.FixedRate.Instrument (Instrument(..))
import Daml.Finance.Interface.Types.Common.Types (InstrumentKey(..), Id(Id))
import Daml.Finance.Interface.Types.Date.DayCount (DayCountConventionEnum(Act360))
import DA.Map (Map)
import qualified DA.Map as Map
import qualified DA.Set as Set
type Bond = Daml.Finance.Instrument.Bond.FixedRate.Instrument.Instrument

-- ### TODO
--   * Include "start date" of the loan (used to calculate coupon payment dates)
--      * Equal to the day at which the loan principal amount is transferred to the borrower.
--   * Figure out what to use as the output of this step to be used as input to the servicing process.
--   * Use daml-finance types for specifying e.g. coupon payment schedule (cf. https://docs.daml.com/daml-finance/reference/code-documentation/daml-finance-rst/Daml-Finance-Instrument-Bond-FixedRate-Instrument.html)
--      * Maybe just include the payment schedule in the final output of this whole process (to be used as input for the servicing process)

-- | Rate per annum.
-- E.g. "3.5% per annum" is represented as 0.035
newtype RatePerAnnum = RatePerAnnum { unRatePerAnnum : Decimal }
  deriving (Eq, Show)

-- | An application for a loan by a borrower
-- NOTE: Borrowers may create and freely submit loan applications to agents. We do
-- not limit the ability to apply in any way.
template LoanApplication
  with
    borrower : Party
    agent : Party
    amount : Numeric 2
    duration : Int  -- ^ Number of years
    maxInterestRate : RatePerAnnum
    prospectus : Text
    -- ^ an explanation, by the borrower, of what the loan will be used for
    -- TODO: The lenders (not just the underwriter) want to see the prospectus too
  where
    signatory borrower
    observer agent

template UnderwritingRequest
  with
    underwriter : Party
    uuid : Text -- Generated client-side by the agent so that each 'LoanApplication' has unique ID. We could also use a 'ContractId LoanApplication' to be the unique ID for a 'UnderwritingRequest', but the borrower has the ability to archive the LoanApplication, and we don't want to give the borrower the ability to delete a piece of data that is referred to by contracts involving other parties.
    loan : LoanApplication -- See comment above
  where
    signatory loan.agent
    observer underwriter
    key (loan.agent, uuid) : (Party, Text)
    maintainer key._1

template UnderwritingResult
  with
    underwriter : Party
    agent : Party
    uuid : Text
    result : Bool
  where
    signatory underwriter
    observer agent
    key (underwriter, agent, uuid) : (Party, Party, Text)
    maintainer key._1

    nonconsuming choice UnderwritingResult_Disclose : ContractId UnderwritingDisclosure
      with
        disclose_to : Party
      controller agent 
      do
        create UnderwritingDisclosure with
          underwriting = this
          participant = disclose_to

template UnderwritingDisclosure
  with
    underwriting : UnderwritingResult
    participant : Party
  where
    signatory underwriting.underwriter, underwriting.agent
    observer participant

-- | A request created by the agent inviting a single participant to make an offer on a 'LoanApplication'
template LoanRequest
  with
    agent : Party
    uuid : Text
    underwrite : ContractId UnderwritingDisclosure
    totalApplicationAmount : Numeric 2
    -- ^ Invariant: must be equal to the LoanApplication.amount that is pointed to by this contract's key
    participant : Party
    -- ^ The agent creates one 'LoanRequest' for each participant from whom it wants an offer
  where
    signatory agent
    observer participant
    key (agent, participant, uuid) : (Party, Party, Text)
    maintainer key._1

-- | An offer by a participant to loan part (or all of) of the amount specified by the LoanApplication
template LoanOffer
  with
    agent : Party
    uuid : Text
    participant : Party
    amount : Numeric 2
    rate : RatePerAnnum
    -- TODO: for now we just reject offers that are greater than LoanApplication.maxInterestRate, but eventually we'd like to accept all offers that makes it possible for the agent to offer a final loan of less than or equal to LoanApplication.maxInterestRate.
  where
    signatory participant
    observer agent
    key (participant, agent, uuid) : (Party, Party, Text)
    maintainer key._1

template SyndicatedLoanOffer
  with
    agent : Party
    uuid : Text
    borrower : Party
    amount : Numeric 2
    rate : RatePerAnnum
    -- other terms: term, fees, covenants, etc.
    --NOTE: Maybe a covenant, once agreed by the borrower, could actually grant access to some on-chain data in the future, which is necessary to enforce it. and this could also trigger on-chain modifications of the loan.
  where
    signatory agent
    observer borrower
    key (agent, uuid) : (Party, Text)
    maintainer key._1

data LoanTerms = LoanTerms with
    amount : Numeric 2 -- Principal. TODO: for now always equal to LoanApplication.amount
    rate : RatePerAnnum
    -- ^ The interest amount paid by the borrower yearly is (amount * rate).
    -- ^ TODO: for now this is always equal to LoanApplication.maxInterestRate, but we want this to become an amount-weighted average of offered participant rates
    duration : Int
    -- ^ Number of times the borrower pays interest, as well as the number of years after which the principal amount must be returned to the lenders.
      deriving (Eq, Show)

template AcceptedLoan
  with
    agent : Party
    borrower : Party
    amount : Numeric 2
    rate : RatePerAnnum
  where
    signatory borrower
    observer agent

-- The final loan agreement should include all parties. The privacy barrier is dropped in this final step. In the bookbuilding process, no identities are revealed.
template LoanAgreement
  with
    agent : Party
    participantsWithAmount : Map Party (Numeric 2)
    borrower : Party
    uuid : Text -- Points to UnderwritingRequest.uuid
    prospectus : Text
    loanTerms : LoanTerms
  where
    signatory agent, borrower, Map.keys participantsWithAmount

template PendingLoanAgreement
  with
    agreement : LoanAgreement
    signed : [Party]
  where
    -- TODO: ensure clause
    signatory agreement.agent, signed
    observer Map.keys agreement.participantsWithAmount

-- Need to provide some proof to P that A gave the loan amount to the same B that was underwritten. Can we do this without revealing B's identity?

-- NOTE: pays to agent for now. TODO: pay to participants
loanAgreementToBond
  :  Party -- the Fed (the issuer and depository of USD)
  -> LoanAgreement
  -> Bond
loanAgreementToBond fed a =
  Instrument with
    depository = a.agent -- same as agent for now
    issuer = a.borrower
    id = Id a.uuid
    version = "0"
    description = "Fixed-rate bond"
    couponRate = unRatePerAnnum a.loanTerms.rate
    periodicSchedule = undefined
    holidayCalendarIds = [] -- NOT USED!
    calendarDataProvider = a.agent -- NOT USED!
    dayCountConvention = Act360 -- TODO: how does this impact servicing rules?
    currency = usd
    observers = Map.fromList $ zip (map show [1..]) (map Set.singleton (Map.keys a.participantsWithAmount))
    lastEventTimestamp = error "TODO"
  where
    usd = InstrumentKey with
      depository = fed
      issuer = fed
      id = Id "USD"
      version = "0"
