module Workflow.SettlementProposal where

import DA.Functor
import DA.List (sort)
import qualified DA.Map as Map
import Daml.Finance.Interface.Types.Common.Types

import qualified Daml.Finance.Interface.Settlement.RouteProvider as RouteProvider
import qualified DA.Set as S

import qualified Daml.Finance.Interface.Settlement.Factory as Settlement
import qualified Daml.Finance.Interface.Settlement.Batch as Batch

import Daml.Finance.Interface.Settlement.Batch qualified as Batch (I)
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (I)
import Daml.Finance.Interface.Settlement.Types (RoutedStep, Step(..))
import DA.Set (singleton)

import Workflow.Origination

template SettlementProposal
  with
    loan : LoanAgreement
    sigAccumulator: [Party] -- Acquire acceptance from all parties
    routeProviderCid : ContractId RouteProvider.I
    settlementFactoryCid : ContractId Settlement.F
    bond : InstrumentKey
  where
    signatory loan.agent::sigAccumulator
    observer loan.borrower::(map fst $ Map.toList loan.participantsWithAmounts)

    choice Accept_Borrower : Either (ContractId SettlementProposal) (ContractId SettlementProposal, ContractId Batch.I, [ContractId Instruction.I])
      controller loan.borrower
      do
        let lenders = (map fst $ Map.toList loan.participantsWithAmounts)
            lendersAndBorrowers = loan.borrower::lenders
            id = "settlement-" <> (show settlementFactoryCid) <> "-" <> (show routeProviderCid)
        debug $ show lendersAndBorrowers
        if (sort sigAccumulator) == (sort lenders) then do
          (batchCid, settleInstructions) <- settleTransactions loan lendersAndBorrowers id routeProviderCid settlementFactoryCid bond
          updatedContract <- create this with sigAccumulator = loan.borrower::sigAccumulator
          return $ Right (updatedContract, batchCid, settleInstructions)
        else do
          updatedContract <- create this with sigAccumulator = loan.borrower::sigAccumulator
          return $ Left updatedContract

    choice Accept_Lender : Either (ContractId SettlementProposal) (ContractId SettlementProposal, ContractId Batch.I, [ContractId Instruction.I])
      with
        currLender : Party
      controller currLender
      do
        assertMsg "Must be an authorized lender" $ elem currLender (map fst $ Map.toList loan.participantsWithAmounts)
        let lendersAndBorrowers : [Party] = loan.borrower::(map fst $ Map.toList loan.participantsWithAmounts)
            id = "settlement-" <> (show settlementFactoryCid) <> "-" <> (show routeProviderCid)
        debug $ show lendersAndBorrowers
        if sigAccumulator == loan.borrower::(map fst $ Map.toList loan.participantsWithAmounts) then do
          (batchCid, settleInstructions) <- settleTransactions loan lendersAndBorrowers id routeProviderCid settlementFactoryCid bond
          updatedContract <- create this with sigAccumulator = currLender::sigAccumulator
          return $ Right (updatedContract, batchCid, settleInstructions)

        -- add the current choice controller to the list of acquired signatures
        else do
          updatedContract <- create this with sigAccumulator = currLender::sigAccumulator
          return $ Left updatedContract

    choice Decline : ()
      -- ^ Decline the request.
      controller loan.borrower::(map fst $ Map.toList loan.participantsWithAmounts)
      do pure ()

    choice Withdraw : ()
      -- ^ Withdraw the request.
      controller loan.agent
      do pure ()
    choice ExecuteSettlement : ()
      with
        batchCid : ContractId Batch.I
      controller loan.agent
      do
        exercise batchCid Batch.Settle with
          actors = S.singleton loan.borrower
        return ()

settleTransactions :
  (HasField "agent" r1 Party
  , HasField "amount" r2 (Numeric 10)
  , HasField "borrower" r1 Party
  , HasField "instrument" r2 InstrumentKey
  , HasField "loanTerms" r1 r2
  , HasField "participantsWithAmounts" r1 (Map.Map Party (Numeric 10))
  , HasExercise t1 RouteProvider.Discover [RoutedStep]
  , HasExercise t2 Settlement.Instruct (a, [c])
  )
  => r1
  -> [Party]
  -> Text
  -> ContractId t1
  -> ContractId t2
  -> InstrumentKey -- ^ Bond
  -> Update (a , [c])
settleTransactions loan lendersAndBorrowers id routeProviderCid settlementFactoryCid bondInstrumentKey = do
  -- Settlement of lenders (USD)
      -- Lenders scheduled sending of funds to Agent.
  let stepsFromLenderUsd = (Map.toList loan.participantsWithAmounts) <&> \(lender, investAmount) ->
        Step with
          sender = lender
          receiver = loan.agent
          quantity = Quantity loan.loanTerms.instrument investAmount
      -- Agent schedules sending of funds to Borrower.
      stepsToBorrowerUsd =
        Step with
          sender = loan.agent
          receiver = loan.borrower
          quantity = Quantity loan.loanTerms.instrument loan.loanTerms.amount
      stepsUsd = stepsFromLenderUsd <> [stepsToBorrowerUsd]
  -- Settlement of lenders (bond)
      -- Agent sends Bonds to Lenders.
  let stepsBond = (Map.toList loan.participantsWithAmounts) <&> \(lender, investAmount) ->
        Step with
          sender = loan.agent
          receiver = lender
          quantity = Quantity bondInstrumentKey investAmount

  -- Discover settlement routes for the steps
  routedSteps <- exercise routeProviderCid RouteProvider.Discover with
    discoverors = S.fromList $ lendersAndBorrowers
    contextId = None
    steps = stepsUsd <> stepsBond

  -- Instruct settlement
  exercise settlementFactoryCid Settlement.Instruct with
      instructors = S.fromList $ lendersAndBorrowers
      settlers = singleton loan.borrower
      id = Id id
      description = "Settlement for " <> id
      contextId = None
      routedSteps
      settlementTime = None -- i.e., immediate settlement
